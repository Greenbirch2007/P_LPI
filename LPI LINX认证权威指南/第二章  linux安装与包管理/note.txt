

第二章  linux安装与包管理

只需要掌握Debian APT与RPM两组包工具的一个即可


1.102.1  规划磁盘布局

考验你的磁盘规划能力，如果分配磁盘，使其适合用来安装linux系统，特别
是如何在硬盘开头处划分一个/boot分区，借此规避BIOS的1024磁柱限制


1.102.2  安装开机管理程序


能够选择，安装，设定开机管理程序(boot manager),包括LILO 与GRUB


1.102.3 源代码的编译与安装

考验更艳遇一般软件的编译安装步骤，包括如何修改Makefile，使其适合你的系统环境

1.102.4 共享函数库的管理

必须理解共享函数库的概念，包含如何找出特定程序所需的共享函数库以及如何设定它们

1.102.5 Debian包管理系统

在Debian-based系统上进行各式各样的包管理工作，包括如何利用其命令行与交互式工具
来进行包的安装，升级，解除安装，或找出含有特定文件或软件的包。
要懂得超出包的信息，比如，版本，内容，依赖关系，整体性，安装状态等

1.102.6 Red Hat包管理系统

包管理工具从原本的Debian APT转换成 Red Hat RPM

规划磁盘布局


在安装linux的过程中，要决定如何划分磁盘，将文件系统分散到更多个分区(甚至不同的磁盘)有很多好处


关于磁盘，分区，linux文件系统的顶层目录


系统考虑

在划分Linux的磁盘布局时，有几项因素需要考虑，包括：
磁盘的容量
系统的规模
系统的用途
预期的备份方法与备份空间

除了只读的文件系统(CD-ROM或共享的/urs分区)，linux的大多数文件系统都应该保留
一些可用的弹性空间。用于保存个人数据的文件系统(例如/home),应要有足以满足用户
所需的最大可用空间。但如何考虑到磁盘实际空间，可能必须设法在"文件系统的数量"
和"可用空间容量"之间取舍，找出最能够有效利用磁盘空间的配置方法

有限磁盘空间的规划方法

若磁盘空间有限，可以减少文件系统的梳理，让原本应该放在个别分区的文件系统共享同一
块连续可用空间。


比如有1G磁盘空间来安装Linux，则应该尽量减少分区梳理：

/boot

50 MB. 用于一个小型的/boot文件系统当第一分区，可确保所有内核映像问价你的位置
必定在磁盘的1024-cylinder之前

/

850 MB.用一个大的root分区来容纳/boot之外的所有东西

swap
 
100 MB

就上面的梨子，由于整个root分区都位于1024-cylinder之前，所以/boot其实也
可以直接并入root分区

充裕磁盘空间的规划方案


在资源比较充裕的大型系统，其磁盘布局方式主要以"功能性"作为基本考虑因素。比如
备份方式，各文件系统的规模等。以一个具有100GB磁盘空间的文件服务器为例，
假设它的主要用途是提供共享磁盘空间给局域网络上的用户(透过NFS或 Samba),则
我们应该将它的"系统软件"与"数据存储"空间分开。


/boot
 50 MB. 确保内核映像文件的位置必定在磁盘的1024-cylinder之前

swap
 	1GB. 文件服务器系统的内存用量很大

/

 500 MB (至少)

/usr
 4-8 GB. 用于存储系统程序


/var 

 2-4 GB .将日志文件(log file)放在专属分区，可在日志文件规模意外扩大到
塞满文件系统时，避免影响到系统的稳定性


/tmp

 500 MB.将临时盘放在独立的分区，可避免在文件系统被塞满时影响到系统的稳定性


/home

 90GB 。供所有用户用于存放数据的专属分区

在实际操作中，重要的文件服务器会使用备份储媒(例如 RAID 0, RAID 5)
或将/home 放在具有硬件控制器的磁盘阵列上


系统角色

系统担任的角色也会影响磁盘布局。用于服务无磁盘驱动工作站的NFS服务器的/usr,/home,
/var 的空间应该要比较充裕，邮件服务器与网页服务器的/home 与/var应该要有比较多的
空间，而日志服务器只要让/var 或/var/log 有足够空间即可


备份方法


备份方法也会影响到磁盘分区的划分方法。某些备份方法是以磁盘分区为备份单位。
列在/etc/stab里的每个文件系统都会被当成个别的备份单位，所以这些文件系统的
容量就不能超过备份储媒的存储能力


事实上，"系统角色"与“备份方法”这两个因素有时候会互相影响。
如果你希望备份文件服务器的/home 文件系统，但备份储备只能容纳32 GB,
则存放 /home 文件系统的分区就不应该超过32 GB,除非你采用不以分区为单位的备份方法


交换空间


在安装Linux，要设置一个swap分区。这个特殊的磁盘空间是让操作系统来作为主存储器使用，
利用这种方法，内核可同时运行比主存储器容量更多的程序

一个经验决定交换空间应该设定为多大：
主存储器(RAM)的总容量的两倍。例如，
若你的系统有512 MB RAM,则交换空间至少要有1GB.

实际需要的交换空间取决于系统的用途，敷在状况，同时运行的进程数量与程序规模，
但基本规则是不低于主存储器容量的两倍


一般性的划分原则


1.保持一个小的root文件系统(/),将目录树的其余部分分散到其他分区。
root 文件系统受损的机会与其容量成正比，小型root文件系统比较不容易受损

2. 将/boot文件系统独立于一个小分区，而且该分区的位置一定要在1024-cylinder之前

3. 将/var 独立出来，给它可容纳日志文件的足够空间。日志文件轮替机制(rotation)
会尽量保持所有文件的大小在合理范围内，并自动删掉过期的日志文件。
独立的/var文件系统可避免轮替机制意外失效时，成长过量的日志文件排挤了系统其余
部分所需的磁盘空间

4. 将/tmp独立处理。其容量依应用程序实际需求而定，一般而言，它应该要足以
容纳所有用户同时活动时所产生出来的全部临时文件

5. 将/usr 独立处理。其容量要大到足以应付重编译内核的需求。独立的/usr使得其他
工作栈可透过read-onlyu NFS共享此文件系统

6. 在多人使用的系统中将/home 独立处理。如果用量庞大，应该将它放在一个磁盘阵列子系统


7.交换空间至少是主存储器容量的两倍大。如果主存储器容量不大(少于64 MB),
则应该让交换空间有三倍或四倍于主存储器的容量



考点

磁盘布局是"系统需求"与"可用资源"两者的妥协结果，没有单一范本可代表最佳配置。
必须考虑的因素，包括内核映像文件(位于/boot)要放在1024-cylinder之前，有效
使用多磁盘的方法，重要分区(/var, /usr)的容量规划，root文件系统的重要性，
交换空间的容量




安装开机管理程序

x86 PC的整个开机过程分成两个阶段：
第一阶段始于BIOS 对硬件进行自我检测(POST)与初始化，使其进入可以加载操作系统的
状态，并找出MBR(从硬盘开机)或bootstrap程序(从软盘开机)

第二阶段的作用是加载操作系统：从软盘开机时，BIOS会运行软盘上的引导区上的bootstrap程序
直接将linux内核(或其他操作系统)加载进内存；从硬盘开机时，则分成两个步骤：

1. 运行MBR上的启动程序(bootstrap)

 MBR (Master Boot Record)是硬盘最外轨的第一个扇区(sector),其长度固定为512 byte
MBR 本身分成两个部分：前面446 byte是bootstrap程序，其余为分区表(partition table)
Bootstrap随操作系统而异，但是其作用同样是解读分区表，
借此找出操作系统的内核或内核的加载程序(boot loader)

2. 启动linux内核(boot loader)

Boot Loader的任务是取得开机参数(由用户提供或从配置文件取得)，超出磁盘上的内核映像
文件(kernel image),将内核加载到内存并传递开机参数传给内核，最后交出CPU的控制权给内核


linux内核本身不含bootstrap程序，而是由开机管理程序(boot manager)提供。
在x86 Linux系统上，最常用的开机管理程序有两种，分别是LILO(Linux LOader)与
GRUB:前者只能用在x86平台上，后者号称可跨越多种平台。
两者都提供了简单的操作画面，让用户可选择想要启动的内核，甚至启动linux之外的其他操作系统



LILO

Linux Loader(LILO)是专门用于x86平台的boot loader,它不仅可用来载入linux内核，
也可用来加载其他操作系统的"引导区"(boot sector),LILO 本身分成两部分：

1.boot loader

   boot loader 的任务是找出并加载操作系统内核。不过，由于x86平台的MBR相当小，
 不足以容纳整个boot loader,所以LILO的Boot loader是一个两阶段的陈故乡。
 将第一阶段称为bootstrap，第二阶段称为OS loader.

bootstrap必须放在磁盘的MBR,这样才能让BIOS找到。LILO bootstrap唯一的任务
是启动磁盘上的OS loader。
OS loader的任务是显示出一个提示符号，让用户可在开机期间选择所要用的内核(或其他
操作系统)，接着找出内核并将其解压缩(如果压缩了的话)，加载到内存，最后启动内核。


2. lilo命令

这部分的LILO也成为map installer.其作用是解读/etc/lilo.conf配置文件，
将配置数据与磁盘结构信息转换成boot loader方便解读的格式，
最后改写MBR.
/etc/lilo.conf 配置文件注明了内核映像文件(kernel image)的路径，开机画面
的屏幕模式，默认的开机磁盘等，每次修改/etc/lilo.conf配置文件，都要重新
执行一次lilo命令，才能使新配置生效


Boot Loader

当系统BIOS启动boot loader之后，会出现提示画面：
LILO

如果你的Linux系统同时装了多个内核，就可以在此选择要使用哪一个内核开机并
传递一些参数给内核。除了linux内核之外，LILO也可以用来加载其他的操作系统。

在LILO:提示符号之后按下 Tab键，可列出所有可用的kernel image让用户选择。
在列出来的kernel image中，名称末端加注了星号(*) 的默认要载入的内核


LILO: TAB


如果不理会LILO提示符号，那么经过一段预定时间后，LILO会自动加载默认内核

LILO map installer 与其配置文件

boot loader 必须依靠LILO map installer所安装的信息，才能顺利从硬盘完成开机过程


lilo命令会将第一阶段的LILO boot loader(bootstrap code)写到MBR,
使其能以适合该系统的方式开机。一般而言，当你在安装linux系统时，安装程序会帮你
完成这些内容，但每次重建一个新内核或修改/etc/lilo.conf配置文件时，就必须重新执行一次lilo


lilo命令(或称为"map installer") 能解读/etc/lilo.conf配置文件并写出一个map文件，
boot loader依据map文件所提供的信息来找出并启动linux内核(或其他操作系统)

常用选项

-C config_file
  读取指定的config_file文件，而非默认的/etc/lilo.conf配置文件

-m map_file

  将 map_file写到配置文件指定的默认位置


-q 
  查询(query) 当前的配置文件

-v 
  输出详细的信息

/etc/lilo.conf配置文件记录内核映像文件的相关信息，会映像LILO整体行为的选项(开机磁盘
的位置，等待时间等)以及效力仅及与个别内核映像文件的选项(标记，root文件系统的位置等)
一般情况下只会用到少数几个选项


一个简单的LILO配置文件样本


/etc/lilo.conf 配置文件样本

boot = /dev/asd
timeout=50
prompt
read-only
map=/boot/map
install=/boot/boot.b
message=/boot/message
default=linux


image=/boot/vmlinuz-2.6.10
	label=linux
	initrd=/boot/initrd-2.6.10.img
	root=/dev/sda2

image=/boot/vmlinuz-2.4.31
	label=oldkernel
	root=/dev/sda2

上述配置文件的每一行的说明如下：

boot

	指出含有引导区(MBR)的硬盘，应该将它指向BIOS会优先搜寻的IDE或SCSI硬盘。
	上面，以第一块SCSI硬盘(/dev/sda)作为开机设备


timeout
 	等待用户做出选择的时间，让计算单位为0.1秒。若搭配prompt选项时，这段时间
就是"LILO":提示符号持续出现的时间。

例子中，若用户没有在"LILO:",提示符号出现后的5秒内按下任何键，LILO将启动默认内核。
若不想每次重新开机时都停滞在LILO:提示画面，就应该指定一个适当的timeout值


prompt
	要求boot loader显示出"LILO:"提示符号。如果没有指定prompt选项，用户必须
	在LILO启动时按下 Shift,Ctrl或Alt这三个键的其中之一，才会出现"LILO"

read-only

	第一次挂载root文件系统时挂载成"只读"(read-only)模式。一般来说，系统启动
	程序会在稍后将root文件系统重新挂载成read/write模式


map
	指定map文件的位置。默认位置为/boot/map

install
	指出含有新引导区内容的文件。，默认文件是/boot/boot.b

default
	默认内核的"标记"


image
	指定可开机的内核映像文件。在同一个配置文件中可同时存在多个image语句，
	使你在开机时可以选择其他内核(或其他操作系统)


label 
	定义一个代表特定image的标签。常以描述内核版本或系统用户的字符串来当
	标签。例子中，指定了两个内核映像文件并以label分别赋予它们不同的识别名称


root
	用于个别的image段落，指定该映像文件所用的root文件系统所在的分区

原则上，只要有能力从给定的/etc/lilo.conf配置文件样本中看出该系统开机规则即可


LILO的位置

在安装系统的过程中，安装程序坑你会问你要将LILO放在磁盘的引导区(MBR)还是
root翻去。对于只使用linux的系统，可以将LILO放在引导区，而不必担心会影响到
其他boot loader.另一方面，若打算在同一部计算机上安装其他操作系统(如,windows)
就应该将该操作系统的boot loader放在引导区


注，多重开机与多重操作系统的配置超过了LPIC Level 1的范畴

应考诀窍：

你必须要能够辨认"map installer"与 "LILO boot loader"之间的差别：前者
是一个用于命令行环境的工具程序，能将给定的配置信息编成后者可读取的map文件；
后者是存放在引导区的两阶段程序代码，由系统BIOS在开机期间将其启动，
并依据前者提供的map文件完成实际的操作系统启动过程，这两者都包含在LILO包中


GRUB

GRUB (Grand Unified Bootloader)是一个多段式开机管理程序，这一点跟LILO一样：
不同的是，GRUB的设计相当灵活，它支持多种文件系统与操作系统，几乎可启动任何一种内核


GRUB 设备命名法则

GRUB 以下列法则描述磁盘设备：

(xdn[.m])

其中，xd代表磁盘类型，例如,fd表示软盘，Hd代表硬盘(部分规格)；
n是磁盘的BIOS编号顺序，从0起算；选择型的m代表分区编号，同样也是从0起算


以下是几个有效的GRUB设备名称范例：

(fd0)
 第一张软盘

(hd0)
 第一块硬盘

(hd0,1)
	第一块硬盘上的第二个分区

GRUB不刻意区分IDE与SCSI硬盘，只在意BIOS所见到的磁盘顺序。
因此，如果你要更改BIOS的开机顺序(比如，原本是IDE后SCSI,而现在改成先SCSI后IDE)
则原本的GRUB设备编号就不是指向你原本预期的磁盘



安装GRUB

最简单的方法是用grub-install script，若要将GRUB安装在第一个硬盘的MBR,
你应该像下面这样使用grub-install:


grub-install '(hd0)'



grub-install 会先搜寻设备对应的文件(默认位置在/boot/grub/device/map),借此
判断BIOS磁盘编号与Linux之间的对应关系。如果没有找到对应文件，则会试着猜测
系统上存在那些磁盘以及它们与BIOS磁盘之间对的对应关系。

若grub-intall猜错了， 只要编辑/boot/grub/device/map，然后重新运行一次grub-intallJike 

设备对应文件的每一行各描述一个"BIOS磁盘-linux设备"对应关系

(disk) /dev/device

例如，你的系统上有一个软驱与一块SCSI磁盘，则它们的对应关系应描述如下：

(fd0) /dev/fd0
(hd0) /dev/sda


你也可以使用命令来安装GRUB.以先前的grub-install例子所实现的同样效果为例，
等效的grub操作方式如下(假设/boot是位于第一个磁盘的第一个分区)

grub

GRUB 的开机程序

当BIOS加载并执行GRUB后，若它找不到配置文件(或配置文件没有指出应该要加载哪一个内核)
则它会显示一个下面的提示画面

这时候GRUB会其他你依次序输入下列指令启动linux内核


例如，在一台安装了red Hat 8.0 的计算机上，若它的/boot是位于/dev/hda1,root文件
系统位于/dev/hda2,则可使用下列操作顺序来启动该系统

GRUB的配置文件

GRUB也可以有一个漂亮的开机菜单画面，让用户不必面对刻盘的GRUB shell.
要显示开机菜单，GRUB需要一个特殊的配置文件——/boot/grub/menu.lst


注意

GRUB配置文件的位置与名称随系统而已，在Red Hat系统，默认的配置文件是
/boot/grub/grub.conf


GRUB的配置文件定义构成菜单的各个项目以及启动各项目所需的命令。同样以先前的Red Hat 8.0系统
为例，我们可以准备一个类似下面的配置文件：


default=0
timeout=3
title Red Hat Linux (2.4.18-14)
	root (hd0,0)
	kernel /vmlinuz-2.4.18-ro root=/dev/hda2
	initrd /initrd-2.4.18-14.img



GRUB还有很多功能，包括支持串行端口控制台(serial console,在Spare平台上常见)
启动其他操作系统等


源代码的编译与安装

open source 软件所提供的价值超过专利产品。
开源软件是以"源代码"(source)的形式来发布，这表示在使用之前，必须现将源代码
编译成可执行的binary形式


linux包发行公司会将常用的open source 软件封装成"包"(package)形式，
让用户方便安装。”包“通常含有预先编译好的binary程序文件以及相关的配置文件与
说明内文件，用户可利用包发行公司提供的工具(RPM或APT)来安装包。

取得源代码


构成"linux distributio" 软件的源代码，可从多种来源取得。第一个会被想到来源是
linux发布厂商(如，RedHat)提供的光盘与往后咱。
linux系统上的大多数常用工具都出自FSF的GNU project

open source 软件主要几种在Source Forge (http://sourceforce.net/)

绝大多数来自”源头“的源代码都是封装成所谓的"tarball"格式


何谓 tarball?

一般而言，有分量的Open Source 软件(Sendmail, Samba,BIND,Apache,Mysql等)
都含有很多文件，包含源代码，说明文件，编译支持文件(makefile,configurescript)
配置文件样本等。
一般是用tar将它们封装成单一文件，再以gzip压缩。讲过两道处理手续的文件就称为tarball,
其扩展名为.tar.gz 或 .tgz


tarball 最主要的好处是方便在网络上传播，另一个好处是可使用标准工具解开


解开 tarball


解开tarball需要两个不好走，先用gzip-d 或gunzip解压缩，然后用tar 展开压缩后的文件

例如要解开tarball.tar.gz文件

gzip -d tarball.tar.gz (或gunzip tarball.tar.gz)

tar xvf tarball.tar


也可以利用管道将gzip -d 或gunzip 的输出转接到tar的输入，避免中间的tar文件

gzip -dc tarball.tar.gz | tar xv


使用gzip 的-c选项，避免gzip擅自删除原本的tarball

使用GNU tar，只用一个步骤解开


tar zxvf tarball.tar.gz

应考诀窍


需要熟悉各种解开tarball的方法。此外必须确实了解，tar不仅可以封装磁带的内容，
也可以直接封装文件与目录


编译 Open Source 软件

解开tarball之后的下一步，是将源代码编译成可执行的程序文件，也就是binaries

要顺利完成编译，你的系统至少具备适当的开发工具软件，
包括GNU C编译器与make编译工具。
必要时，你可能还要另外安装其他支持库或新版的配套软件爱你


实际的而编译程序随软件而异，但大致分为三步：configure,make,make install


configure


对于有规模的Open Source软件包，在解开之后，应该在源代码目录树的顶层找到一个
configure script。一般而言，不必修改或设定此脚本，就可以直接执行它，
configure的作用是检验系统的实际环境是否具有所需的编译器，函数库，工具以及
其他支持项目(标头文件或其他软件包)。它利用浙西实时手机来的现场信息，
产生一个适合该系统的Makefile文件，以便顺利完成后续的编译工作。
如果configure发现你的系统缺乏某些必要项目，它会提示一些警告信息，让你
直到系统缺少什么


configure的另一个工作，是让你设定编译器选项。比如，选择安装位置，
是否要支持特定功能，相关函数库的位置等。实际的编译器选项随软件而定，
但通常你可用configure --help列出所有编译器选项

binary的复数形式，专门用来指称操作系统可直接执行的ELF文件

configure script 本身是程序设计者以autoconf工具程序所产生的。不过，autoconf已经
超出 考试范围
make

make原本是一个用来简化编译操作的工具软件，但后来衍生出许多用途，称为自动化工具。
使用make时，必须编写一个Makefile,以规定的语法描述你的”工作目标“(target)
各目标之间的"依赖性"以及满足依赖性所需要执行的动作


make能检查文件的修改时间，借此判断内显示环境是否满足Makefile所描述的依赖性，
并自动执行满足依赖性所需的动作，最后达成想要的工作目标


对于编译工作而言，最终目标当然是产生"可执行文件"(executalbes 或binaries)
而"可执行文件"本身是由多个"目标文件"(object file)连接而成，"目标文件"
则是从源代码文件编译出来的。每当程序员修改源代码，其文件修饰日期必定比最近
一次产生的"目标文件"更晚，make便可由此判断应该重新编译哪些源代码


"目标文件"则是从源代码文件编译出来的。每当程序员修改源代码，其文件修改日期必定
比最近一次产生的”目标“



make [-f makefile] [ option [...]]  [target]

-f filename 使用特定文件作为makefile

-j number_of_jobs
 
 可同时运行的进程数。如果要加快编译速度，可将number_of_jobs设定为
CPU总数加一(例如，在处理器系统上，理想值是-j 2)。少了没有效果，多了没用


安装已编译好的软件


大多数成熟的open source 软件项目会预先决定程序内文件的位置。
在大多数情况下，它们会期待能放在/usr/local/bin/,除非你在执行
configure时指定了其他位置。
wield方便将软件安装到默认位置，它们的Makefiles会包含一个特殊
的目标(target)，称为install。
用户只要执行make install命令，文件就会被赋值到适当位置并被赋予
适当的权限。


警告

来自源头的软件，它们的默认的安装目录可能不同与你的linux distribution
惯例。

比如，Red Hat linux习惯将服务器软件集中在/usr/sbin目录下，但是
如果你自己编译这类服务器软件，则它们默认的安装目录通常是/opt/或
/usr/local/。如果想升级系统原本已有的软件，要小心
版本差异造成的混乱

应考诀窍：只要对make有基本了解。在实际操作上，要能够
增添或修改Makefile文件里的变量


实例示范： 编译nano

open source 软件的编译过程

1.第一步下载镜像，nano tarball


tar xzvf nano-1.2.1.tar.gz


cd nano-1.2.1

进入目录 

ls -F

建议阅读那些文件名权威大写字面的文件，特别是README与 INSTALL

less README
less INSTALL


通常你可以在INSTALL找到编译与安装程序的说明，包括如何设定编译器
选择项。假设要将nano安装在/opt/目录下，则应该在执行configure的
之后，以--prefix选型指定要安装的位置


./configure --prefix=/opt


几乎所有configure script都提供--help选项，让你列出所有编译期
可以将configure --help的输出信息保存在另一个文件中，以便日后字啊用

./configute --help | tee -/nano_compile_options


使用configute script 顺利产生Makefile之后，变可以使用
make记性实质的编译过程：

make ，编译之后，就可以使用make inlstall 将它安装到你
预选的目录


make 你的path环境变量应该要含有相关的路径


应考诀窍

你应该熟悉如何取得源代码并加以设定，编译，安装。

要准备号关于make,Makefile的问题，以及configure的作用
gzip,tar的用法



102.4 共享函数库的管理
p63





