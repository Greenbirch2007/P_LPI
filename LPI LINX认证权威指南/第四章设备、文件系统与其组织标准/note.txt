
104.1  创建分区与文件系统
	如何划分磁盘分区(partition),并使用各种弄个mkfs工具
	来制作ext2,ext3,Reiserfs,vafs与xfs等文件系统



104.2  维护文件系统的完整性


利用du,df的工具来检查磁盘空间用量，使用fsck来修复问题



104.3  控制文件系统的挂载和卸载

要能自己动手挂载(mount)，卸载(umount)文件系统，知道如何编辑
/etc/fstab配置文件，使它们可在系统开机时自动挂载以及让用户可使用插入式
储媒(磁盘，光盘，磁带等)



104.4  管理磁盘配合

称职的系统管理者懂得分配足够的磁盘配额空间给用户，

要能够设定文件系统的磁盘配额，编辑，检查，产生用户的配额用量报告


104.5  文件范文权限

要懂得linux系统对于文件的保护措施，这包括如何解读文件的quanx模式
如何省适当的权限，让正确的用户能顺利访问文件，同时又避免泄露
隐私和敏感信息

104.6  管理文件的拥有权

文件与目录的"拥有权"(ownership)其实是linux文件安全管理措施的一部分，

也就是访问权限管理的基础。 如何修改现有文件或目录所属的用户或组
以及如何设定新文件的默认组

104.7 链接文件的管理

如何创建，管理文件的链接。Linux的链接文件分成
"硬链接"(hard link)与"软链接"(soft link)
或称"符号链接"(symbolic link)
要理两种链接的差异以及它们的限制


104.8  系统文件的位置

必须对"文件系统层次结构标准"(Filesystem Hierarchy Standard,FHS)

有铜盘性的认识，包括常见文件的位置以及目录的分类。
要直到如何利用标准工具来找出特定文件于系统上的位置


104.1  创建分区与文件系统


"文件系统"(filesystem) 有两种含义：
1，是指文件与目录在储媒(磁盘)上的具体组织方法与结构

2.代表触媒内容的组织结构，也就是"目录树"(directory tree)

linux采取单目录树设计，磁盘分区必须被挂载(mount)到目录
树上的某个节点----"挂载点"(mount point)，才可以
被访问。挂载可以延伸到网络的远程文件系统
对于用户而言，整个过程都是透明的，所面对的都是同样目录树

比如，/usr目录下的文件，不管是位于本地磁盘还是
位于网络另一端的NFS服务器，用户都可以用同样的操作
方法来访问，只要NFS server与网络都正常运作，
用户甚至感觉不到不同，顶多只有速度上的差异

利用特殊技术，根目录(/)甚至可以不必挂载在本机磁盘。

linux下的磁盘驱动器


磁盘接口贵的

一个IDE接口可以连接两个磁盘，但其中之一必须设定为master模式，
另一种必须设定为slave模式

大多数PC都有两个IDE接口，分别称为primary，secondary
所以，一台标准PC最多可连接四个IDE设备，
如果要连接更多的IDE设备，除非主板上有特制的
IDE子系统，否则就要安装额外的IDE适配器次啊可以


磁盘设备

对于IDE设备，linux默认的设备文件定义：

/dev/hda  Primary master IDE(通常接硬盘)
/dev/had  Primary slave IDE
/dev/hdc Secondary master IDE(通常接光驱)
/dev/hdd  Secondary slave IDE



SCSI 设备文件也是类似，但是没有四个设备的限制：

/dev/sda  第一台SCSI设备
/dev/sdb  第二台SCSI设备
...


SATA硬盘的设备文件采用与SCSI相同的命名惯例

应考诀窍


如何依据设备文件的名称来区分磁盘接口是IDE,SCSI



磁盘分区


几乎每种操作系统都可让你将硬盘划分成多个逻辑河北，
也就是所谓的"分区"(partition)
磁盘的划分情况记录在"分区表"(partition table)中。
分区表的格式随计算机型号和操作系统而异


linux支持多种分割格式，但默认使用MS-DOS格式
这种格式允许你将磁盘最多划分成四个"主分区"(primary partition)
或是三个主分区加一个"扩展分区"(extended partition)

扩展分区可被区分成最多12个"逻辑分区"(logical partition)


一个硬盘最多可划分成15个可用的分区

每一个分区(无论何种类型)都有一个对应的设备文件，
其文件名为所属硬盘的设备文件名加上分区编号。
主分区与扩展分区的编号范围为1～4,逻辑分区则从5开始编号


例如，你的IDE硬盘是以master模式接在primary接口(设备文为/dev/hda

它被划分有两个主分区与一个扩展分区，扩展分区本身又被
划分成3个逻辑分区，则各分区对应的设备文件为：

/dev/hda1 (主分区#1)
/dev/hda2 (主分区#2)
/dev/hda3 (扩展分区)
/dev/hda5 (逻辑分区 #1)
/dev/hda6 (逻辑分区 #2)
/dev/hda7 (逻辑分区 #3)

假设有一块SCSI硬盘(或SATA硬盘)
它被划分有一个主分区与一个扩展分区，扩展
分区又被划分成两个逻辑分区，则各分区对应的设备文件如下：

/dev/sda1 (主分区#1)
/dev/sda2  (延伸分区)
/dev/sda5 (逻辑分区#1)
/dev/sda6 (逻辑分区#2)

要熟记各种分区(主要，扩展，逻辑)的编号原则


各家操作系统都提供了分割磁盘驱动器的工具，
Linux系统所提供的工具为fdisk.

每个分区可以各自容纳自己的文件系统，而制作
文件系统的工具是mkfs


根文件系统与挂载点

分区上的文件系统必须被挂载到"目录树"(directory tree)上的某个节点---
称为挂载点(mount point)
挂载点跟普通目录没有不同，只不过它们是用来作为分区(文件系统)的入口。
在未挂载之前，挂载点目录下通常是全空的


目录树的最顶层称为"根"，以/符号表示，它是一个很特殊的挂载点。
当Linux系统开机时，会优先挂载"根文件系统"(root filesystem)
然后才依据/etc/fstab来挂载其他文件系统。至于根文件系统在哪一个分区，
则由Linux内核的开机参数root决定(通常由LILO或GRUB来提供root参数值)


理论上，根文件系统可以包含整个目录树，事实上，许多小型系统也是如此

不应该将所有数据都放在同一个文件系统中。在实践中，常将不同性质的目录分别
对应到不同的分区，甚至是不同磁盘的分区。


至于哪些目录应该放在独立的分区，涉及个人习惯与专业上的据诶到哪个，

/(根目录)
	由于开机过程之初只会挂载根文件系统，所以有些重要目录必须放在此分区，
	系统才能顺利开机。这些必要的目录包括：
	/bin与/sbin 包含必要的系统二进制二建
	/dev 设备文件
	/etc  几乎所有配置文件都在此目录下
	lib   执行/bin与/sbin下的程序时所需要的公共函数库

/boot 
	此目录含有boot loader所需的静态文件，包括kernel image(内核镜像)
	在实践中，常将/boot放在磁盘上的第一个分区，避开BIOS 1024-cylinder的限制


/home

	此目录主要用户存储用户的个人文件。由于是主要工作区，经常变动，而且
	可能需要庞大的存储空间，这些理由使得/home常被防止在独立的分区，
	甚至是独立的实体磁盘或磁盘阵列。不过，对于某些类型的服务(如防火墙)
	此目录也可能不重要


/tmp
	/tmp主要用来存放临时性文件。虽然所需的空间不是很大，但由于其
	权限是完全开放的，所以常被放在自己的专属分区，以免有人恶意在
	/tmp下产生超大文件，而排挤了其他文件系统的可用空间



/var
	此目录专用来存放经常变动的文件，比如日志文件。基于与/tmp同样的
	安全考虑,/var也常被放在独立分区，以免因为忘了定期清理日志文件，
	而排挤了其他文件系统的空间

/usr
	这是一个庞大的目录树，其中包括用户的工具程序，
 	应用程序(/usr/bin, /usr/sbin)
	源程序(/usr/src)
	文件(/usr/share/doc)等
	由于所需的空间相当大，所以也经常被放在独立分区。这样做的一个好处
	由于/usr/目录下的信息几乎都是静态不变的，所以有些管理者
	偏好以只读模式来挂载它，以避免它遭到毁坏。

除了以上6个分区，linux还需要一个swap分区以启动虚拟内存。
swap分区的大小通常是系统内存常量的两倍


在安装Linux系统的期间，上述原则可以帮你规划磁盘分区，
假设一台文件服务器，这台及其有两块IDE硬盘(/dev/hda与/dev/hdc)
容量分别为40GB,80GB

文件服务器的磁盘划分实例



分区             类型             文件系统            容量
/dev/hda1        主要            /boot                512MB
/dev/hda2         主要             /                4GB
/dev/hda3       扩展                                   35.5GB
/dev/hda5        逻辑             /usr               20GB
/dev/hda6       逻辑               /tmp               512MB
/dev/hda7      逻辑                /var                  13GB
/dev/had8      逻辑               swap                   2GB
/dev/hdc1      主要               /home                  80GB


管理分区


对于磁盘驱动器的划分，Linux提供的标准工具是fdisk,另一个是cfdisk.

前者是每家linux版本都提供的文本模式的程序，后者以curse函数库写出来的TUI
菜单式工具。

fdisk

语法
	fdisk [option] device

说明

fdisk 可显示或编辑特定磁盘的分区表(partition table)
它提供一个简单的文本操作接口

fdisk /dev/sda

常用指令

a   改变某分区的bootable标记。习惯上，对第一个主要分区(或是要挂载
	在/boot的分区)应该设立此标记

d  删除一个分区。fdisk会雯你要删除哪一个分区。如果删除扩展翻去，则所有
	逻辑分区会跟着小时；若删除某逻辑分区，则其后的逻辑分区编号将
	往前递补，以维持逻辑分区编号的连贯性

l 列出已知的分区类型与系统标识符


m 显示出指令列表

n 新增一个分区。fdisk会依序问你一下问题：
	分区的类型(primary,extended 或logical)
	分区的编号，起始磁柱(cylinder)的编号，结尾磁柱的编号。
	主分区与扩展分区的编号范围为1~4,逻辑分区从5开始编号。
	输入结尾磁珠的编号时，可以输入"容量值"来代替(例如 "+512M")
	fdisk会依据你给的容量值自动算出结尾磁柱的编号。	
	对于新建的好的分区，fdisk会自动将其类型代码设定为83(Linux native)
	如果该分区要作为swap或是要用于其他操作系统，则必须以t指令来变更
	分区的系统标识符


p   显示内存中的分区表(partition table).如果你所做的变动尚未写回
	磁盘，则你所见到的状态将不同于实际存放在磁盘上的分区表



q 不修改分区表而直接离开fdisk。除非事前以w命令将内存中的分区表写回
	磁盘，否则你所做的改变会消失



t 变更分区的系统标识符(system ID).这是一个十六机制的数字，代表分区
	所含文件系统的类型。Linux分区的系统标识符为83，而Linux swap
	分区的系统标识符为82

w  将内存中的分区表写回磁盘。在此命令之前，你所做的任何改变都不会
	影响磁盘上的分区表



范例


1.显示 /dev/sda上现有的分区表，不做任何变动


fdisk /dev/sda


面对的/dev/sda是一个大容量的200GB磁盘，磁柱有三个主要分区(sda1~sda3)
其中前两个是用于Linux系统，第三个（sda3)是用来安装Windows系统
(从其系统标识符HPFS/NTFS可看出来)
sda4是扩展分区，它占有其余的可用空间；sda5~sda8都是逻辑分区(它们都是
sda4扩展分区的一部分)，其中sda7被用来作为Linux swap


2.从空的分区表开始，在/dev/sdb1 上创建一个300MB的引导区；在/dev/sdb2
创建一个涵盖整个硬盘其余空间的扩展分区；在/dev/sdb5创建一个200MB
的逻辑分区;在/dev/hda6 创建一个128MB的swap分区；
最后将其余空间都分配给/dev/hda7 逻辑分区

fdisk /dev/sdb

在操作过程中，fdisk会给你提示默认值，如果接受，直接按Enter即可。
若需要指定容量，可以使用类似+128M之类的格式，其中M代表megabytes



警告


使用Linux版fdisk工具来制作其他操作系统的分区，可能会遇到一些问题。
原则上，要给什么操作系统用的分区，就应该尽量以该系统的工具来制作


对运作中的系统使用fdisk可能会导致危险。
要被修改分区表的硬盘上不应该有任何分区被挂载咋系统上。
否则，按下w指令之后可能会让你的磁盘崩溃


应该了解分区表，分区的编号方式，并且熟悉使用fdisk创建分区的过程


创建文件系统

对于刚划分好的磁盘分区，必须先安装文件系统才可以供Linux使用。
以Windows的，“安装文件系统"就是"格式化"(formatted)


不同类型的文件系统各有其专属的格式化工具。
例如，ext2,ext3文件系统的制作工具是mkfs.ext2与mkfs.ext3(其实它们
是mke2fs的符号链接):
resiserfs文件系统的制作工具是mkreiserfs.有一个统一的前台工具，
Linux提供了mkfs工具，它会依据指定的文件系统类型，
帮你调用正确的工具来制作文件系统


mkfs
语法

	mkfs [-t fs_type] [fs_options] device



说明


在device 上建立fs_type类型的文件类型。若没有明确指定fs_type,
则默认值是ext2.当mkfs启动对应的格式化工具时，会将你指定的fs_options
传递给该程序。

常用的fs_options选项


-c  检查device是否有故障块。mke2fs与mkdosfs适用
-L label   设定文件系统的卷标(volume label) .仅mke2f适用，对于
	 mkdosfs,此选项要改成-n,而且lebel不得超过11个字符
-q
	抑制执行过程所产生的信息
-v

	详尽显示执行过程中的每一个步骤。适用于mke2fs与kdosfs

范例


1.将/dev/sdb1 分区格式化成ext2文件系统，执行过程尽量低调(不输出详细信息)

mkfs -t ext2 -q /dev/sdb1



2.将/dev/sdb1分区格式化成ext3文件系统，将卷表设定为modisk,
格式化过程要检查故障块并产生完整而详细的输出信息



mkfs -t ext3 -L modisk -cv /dev/sdb1


不同文件系统的格式化工具各有其专属的微调选项，

制作swap分区


每一个正常运作的Linux系统都至少应该有一个swap分区，
这个特殊的分区不被挂载到目录树，而是被当场虚拟内存使用，
制作swap文件系统的工具是mkswap


mkswap


语法
	mkswap device


说明
将指定的分区或文件格式化成交换分区


范例


假设/dev/hda5是一个系统标识符已被设定为82(Linux swap)
的分区，下列命令可以将它格式化为交换空间


mkswap /dev/hda5


事实上，Linux的交换空间不一定要放在独立分区，也可以先准备一个够大
的文件，


然后用mkswap制作此文件的格式


mkswap swapfile


制作好交换分区格式之后，还必须用swapon命令让交换分区生效


swapon /dev/hda5

或

swapon  swapfile

警告


fdisk,mkfs的磁盘工具，对于磁盘数据的破坏力很大，不要搞错！


104.2   维护文件系统的完整性



任何长期运作的操作系统，包括linux在内，文件系统都会渐渐出现出现一些问题：
1.存储空间耗尽，造成某些程序甚至整个系统瘫痪
2. 数据结构损毁，可能是因停电，不当操作或任何无法预料的意外
3. 耗尽所有的inode,以至于无法创建新的文件或目录(及时还有存储空间)


避免问题的不变法则，就是定期的监控与检查。Linux提供一系列工具
帮助你避免，修复文件系统的问题


监控可用的磁盘空间与inode数量

一个可供读写的文件系统有可能不能再继续容纳新文件，这可能是由于存储
空间耗尽或没有剩余的inode可用



Inode是文件系统中的数据结构，用以记录文件的属性，像是位于磁盘中的
位置，拥有者为谁，所属组，访问权限等。
当你使用mkfs制作文件系统时，其实就是将inode的存储区写入磁盘，
文件系统对的inode数量是有限的，而inode的数量也就是文件系统
所能容纳的文件数量的上限。几乎所有文件系统在建立时都会预先设置大量的
inode,所以耗光inode的机会并不多，比较可能发生的情况是同一个分区装填了太多
小文件才会发生这种现象


避免系统分区发生存储空间耗尽或inode不足的下新娘，是系统管理员平时就要
担负的责任。
df 可提供该磁盘空间用量与inode用量


如果耗尽磁盘空间，最简单的解决方法是删除文件或将文件移动到
其他文件系统(不一定可行)
遇到inode不足，那么除非能够删除大量文件，否则所腾挪出来的
inode数量还是有限的


df 
语法
	df [options] [dirs]


说明
显示dirs所属的文件系统的磁盘空间用量。dirs可以是任何目录，df会
依据/etc/fstab配置文件找出dirs的挂载点，然后显示对应文件
系统的信息。若没有指定任何dirs，则df会显示所有已挂载的
文件系统的嘻嘻

常用选项


df -h  以较容易辨识的单位(如M,G)显示数值
df -i 显示inode用量的信息。若不指定此选项，则显示磁盘空间用量


范例

1.查看所有文件系统的磁盘空间用量


df -h

所有文件系统的用量都不超过5成，表示这个系统还有足够的存储空间


2. 查看所有文件系统的inode用量

df -i


例子中，inode用量最多的是/usr文件系统，


3. 查看当前工作目录位于哪个分区

df .

监控磁盘用量
在linux下，du可用于显示个别目录的磁盘用量，搞清楚磁盘空间被哪些目录
消耗掉


du

语法
	du [options] [directories]

说明


显示directories的磁盘使用信息。如果省略directories,则显示当前工作目录的用量


常用选项

du -a 显示所有文件，而不只是目录
du -c  累计所显示的项目的总用量
du -h  以适合研读的单位(如M,B) 来显示数值
du -s  仅显示出指定目录本身的摘要信息，而不是递归显示每个子目录
du -S 子目录的用量不列入计算



范例


1.查看/etc/rc.d的磁盘空间用量


du /etc/rc.d


2. 显示/etc 的磁盘空间用量，包括其下的子目录

du -sh /etc

3. 显示/etc 的磁盘空间用量，但不包含其下的子目录


du -Ssh /etc


4. 找出谁好用了最多的个人目录(/home/*) 空间：

du -csh /home/* | sort -nr 

例子中的表示用户lin郝勇了最多的磁盘空间。
若加上-h选项，那么sort的排序结果将不是你所设想的那样，因为sort
在比较数值大小时不会将单位也计算进入

调整文件系统参数

有许多情况使得管理者想要修改现有文件系统的参数。
例如，某个文件系统的用途改变了，你可能会想要改变其卷标(volume label)
使用tune2fs可以修改ext2与许多其他文件系统的参数


tune2fs

语法
	tune2fs [options] device

说明
修改device 上的ext2或ext3文件系统的可调用参数


tune2fs -l device
	列出device 上的可调参数
tune2fs -c n
	设定足底啊挂载次数为n.当文件系统的挂载次数超过此限制，而文件
	系统再次被挂载时，内核会剔除警告并对此文件系统自动执行e2fsck -p
	(此命令在每次开机时会被自动执行一次)
	若将此值设定为0,表示希望内核忽略此上限度

tune2fs -i n

	设定量词文件系统检查之间的最长间隔时间。若n为纯数值或是其后表示了一个d,
	则解释为"天数"(默认为180天)，若后缀单位为w,则代表"周数";	
	m代表"月数"

tune2fs -L label
	设定文件系统的卷标(volume label).若你的/etc/fstab以卷表来描述
	分区，则必须修改/etc/fstab使其符合现况，或改以设备名称
	(/dev/hda1 之类的名称) 来描述分区


tune2fs -j
	增添一个ext3变动历程文件(journal file)到文件系统并设立has_journal功能标记



tune2fs -m n
	设定保留块的比例为n.在默认情况下，ext2为root管理员保留总块数的5%,
	这表示若某个文件系统有95%都快填满了，则只有root能继续写入数据到该文件	
	系统。这同时意味着着，对于一个用量超过95%的文件系统，df汇报的用量将为100%

	对于非常庞大的文件系统或纯粹专供用户写入数据的文件系统，可以安全地缩减
	保留块的数量，以提供更多存储空间


tune2fs -r n
	设定保留块数为n.此选项的效果类似于-m,只不过它设定的是块数，而
	非比例数

范例


1.列出/dev/hda8de superblock的内容


tune2fs -l /dev/hda8


2. 将/dev/sdb2 的挂载次数上限与检查间隔时间都关闭(归零)


(先查看旧设定值)
tune2fs -l /dev/sdb2 | grep "Maximum mount count"


tune2fs -l /dev/sdb2 | grep "Check interval"


(检查新设定值)


tune2fs -l /dev/sdb2 | grep "Maximum mount count"


tune2fs -l /dev/sdb2 | grep "Check interval"



检查并修复文件系统


意外断电可能导致文件系统出现不一致的现象，管理者必须要予以修复，以
确保日后文件系统的可靠性

不同的文件系统有各种各自专用的检查工具，如mkfs

为了一致，linux提供了一组共同的前台工具，fsck(包括fsck.ext2,fsck.ext2..)
它们会被链接到实际的检查工具(e2fsck)


注意

e2fsck也可以检查ext3文件系统。当发现ext3文件系统没有被干净德卸载，
它会先补全变动记录，然后像平常检查ext2那样来检查ext3文件系统

写入磁盘的数据中有一部分用来描述文件系统的，这些重要信息存放于superblock,
也就是每个分区的第一个块。由于superblock很重要，
所以每固定块数的块中就有一个块被用来存放superblock副本。
以ext2与ext3为例，每8192个块便有一个superblock
编号1,8193,16385...的块都是superblock.
当文件系统出错时，就不保证#1 superblcok的内容的一定正确，
而fsck可依据事先备份的superblock副本来恢复主要的superblock(#1)

fsck

语法
	fsck [options] [-t type] [fs-options] filesystems


说明

检查文件系统的错误并执行用户指定的修复选项。
若没有以-t选项指出文件系统的类型，fsck会假设要被检查的文件系统类型为ext2
在默认情况下，当fsck找到问题时会提示一段信息，让用户决定要如何处理


fsck的常用选项

fsck -A
	检查/etc/fstab文件中所列的文件系统。本选项主要用于开机期间，	
	在挂载文件系统之前。

fsck -N
	不实际执行修复工作，只显示会做出哪些动作


fsck -t type
	指定要被检查的文件系统的类型，默认为ext2.fsck依据type
	来判断应该调用哪一种文件系统的检查程序


e2fsck 的常用选型


e2fsck -b superblock
	让e2fsck知道哪一个superblock的内容是可以相信的。在交互模式下，
	e2fsck会自动判断应该采用哪一个superblock.
	在批处理模式下，则通常会选择8193作为修复主要superblock的依据


e2fsck -c
	检查块是否实体受损


e2fsck -f
	强制进行检查，即使文件系统看起来受损

e2fsck -p	
	自动修复文件系统，而不征询用户的同意


e2fsck -y
	自动对所有提示问题"yes".当文件系统上有许多错误时，你可能会被迫
	回答一大堆"yes"

范例


1.检查/dev/hda5 (尚未被挂载) 上的ext2文件系统：

fsck /dev/hda5


例子中分区是洁净的(clean),也就是没有首都内，所以fsck没有
真正进行任何检查动作


2.强制进行检查


fsck -f /dev/hda5

3.强制进行另一次检查，这次会产生冗长详细的输出信息


fsck -fv /dev/hda5


4.使用-y 选项让fsck自动修复受损的文件系统：


fsck -y /dev/hda5


当linux开机时，开机脚本会自动对/etc/fstab所列的每一个文件系统执行一次
fsck -A,借此检查并修复先前未被妥善卸载的文件系统。
如果检查时发现严重错误而需要管理员介入时，系统将会进入单用户模式(single-user


要熟练  du,df,fsck


104.3 控制文件系统的挂载与卸载

Linux的目录树由各磁盘上的各分区共同构成。即使是可插入式储媒(光驱，软驱)
上的文件系统，也是以类似的方式整合进目录树。
每个文件系统在目录树中都各有自己的空间，称为"挂载点"(mount point)


挂载点通常是空目录，在未挂载文件系统之前，挂载点底下没有任何文件或子目录。
如果你将文件系统挂载到一个非空目录，则该目录的原有内容会暂时小时，直到文件
系统被卸载为止


习惯上，/usr,/home,/var,/tmp会因为特殊考虑而独立于各自的分区，而可插入式
储媒的挂载点则是集中在/mnt或/media的子目录，
例如/media/cdrom , /mnt/floppy等


管理文件系统配置(/etc/fstab)

由于Linux目录树可能横跨多个磁盘上的多个分区，所以必须要有一个机制，
使Linux可在启动时自动挂载各分区，此机制便是记录在/etc/stab
配置文件里的"文件系统配置表"。事实上，/etc/stab不不仅记录了
如何挂载本机磁盘驱动器的信息，插入式储媒与远程网络磁盘(NFS,SMB)
的挂载信息也是记录在此文件中。

/etc/fstab是一般的文本文件，每一行各描述一个文件系统的挂载信息，
这些信息由下列6个字段组成：


1. 设备(device)

	持有文件系统的设备文件的名称。例如/dev/hda1
2.挂载点(mount point)

	用于挂载文件系统的目录。习惯上，含有/etc,/bin等重要目录的根文件	
	目录根文件系统，其挂载点是/:
	含有/var/log , /var/spool等市场变动数据的文件系统，其挂载
	点是/var;含有/usr/bin, /usr/src,/usr/sbin
	等重要程序目录的文件系统，其挂载点是/usr
	含有kernel image的文件系统，其挂载点是/boot

3. 文件系统的类型(filesystem type)

	文件系统的格式。可能的格式包括ext2,ext3,reiserfs(一般硬盘分区)
	swap(交换分区)，iso9660(光盘),msdos(软盘)，vfat,ntfs(windows
	的分区)等

4. 挂载选项(mount option)
	此字段由一系列以逗号分隔的选项构成。可用的选项随着文件系统的类型而定

5. 备份频率(dump frequency)

	dump 程序(Unix的标准备份工具之一)会参考此字段的值，借此判断各文件
	系统的备份频繁度。此字段的值是一个整数，通常，linux的原生文件系统
	(ext2,ext3,reiserf等)是设定为1，其他文件系统(iso9660,
	vfat,msdos...)则设定为0


6. 遍(pass)

	此字段代表启动期间自动检查文件系统时的次序，也也就是传给fsck -A
	参数值，有效值为0，1或2的其中之一，
	0表示不检查，1代表优先检查，2代表所有有限次序为1的文件系统
	都检查过之后才予以检查。
	习惯上，根文件系统的检查次序为1;其他会被自动挂载的文件设定为2
	不自动挂载，可插入式储媒以及远程文件系统则设定为0


范例

1. /etc/fstab 配置文件的实例


例子中的计算机有两块SCSI磁盘，其中/dev/sda是存放操作系统的，而/dev/sdb
主要是供使用者存放数据。最后一个项目(/mnt/fs)是远程的Samba(或Windows)文件系统

在安装linux系统的过程中，安装程序会依据磁盘驱动其的划分现况来自动创建/etc/fstab
配置文件。如果安装了新硬盘或是需要连接远程驱动器。
管理者可在事后修改此配置文件，使其符合最新的实况需求


熟悉/etc/fstab文件的每个字段的功能

挂载文件系统
p189



