
104.1  创建分区与文件系统
	如何划分磁盘分区(partition),并使用各种弄个mkfs工具
	来制作ext2,ext3,Reiserfs,vafs与xfs等文件系统



104.2  维护文件系统的完整性


利用du,df的工具来检查磁盘空间用量，使用fsck来修复问题



104.3  控制文件系统的挂载和卸载

要能自己动手挂载(mount)，卸载(umount)文件系统，知道如何编辑
/etc/fstab配置文件，使它们可在系统开机时自动挂载以及让用户可使用插入式
储媒(磁盘，光盘，磁带等)



104.4  管理磁盘配合

称职的系统管理者懂得分配足够的磁盘配额空间给用户，

要能够设定文件系统的磁盘配额，编辑，检查，产生用户的配额用量报告


104.5  文件范文权限

要懂得linux系统对于文件的保护措施，这包括如何解读文件的quanx模式
如何省适当的权限，让正确的用户能顺利访问文件，同时又避免泄露
隐私和敏感信息

104.6  管理文件的拥有权

文件与目录的"拥有权"(ownership)其实是linux文件安全管理措施的一部分，

也就是访问权限管理的基础。 如何修改现有文件或目录所属的用户或组
以及如何设定新文件的默认组

104.7 链接文件的管理

如何创建，管理文件的链接。Linux的链接文件分成
"硬链接"(hard link)与"软链接"(soft link)
或称"符号链接"(symbolic link)
要理两种链接的差异以及它们的限制


104.8  系统文件的位置

必须对"文件系统层次结构标准"(Filesystem Hierarchy Standard,FHS)

有铜盘性的认识，包括常见文件的位置以及目录的分类。
要直到如何利用标准工具来找出特定文件于系统上的位置


104.1  创建分区与文件系统


"文件系统"(filesystem) 有两种含义：
1，是指文件与目录在储媒(磁盘)上的具体组织方法与结构

2.代表触媒内容的组织结构，也就是"目录树"(directory tree)

linux采取单目录树设计，磁盘分区必须被挂载(mount)到目录
树上的某个节点----"挂载点"(mount point)，才可以
被访问。挂载可以延伸到网络的远程文件系统
对于用户而言，整个过程都是透明的，所面对的都是同样目录树

比如，/usr目录下的文件，不管是位于本地磁盘还是
位于网络另一端的NFS服务器，用户都可以用同样的操作
方法来访问，只要NFS server与网络都正常运作，
用户甚至感觉不到不同，顶多只有速度上的差异

利用特殊技术，根目录(/)甚至可以不必挂载在本机磁盘。

linux下的磁盘驱动器


磁盘接口贵的

一个IDE接口可以连接两个磁盘，但其中之一必须设定为master模式，
另一种必须设定为slave模式

大多数PC都有两个IDE接口，分别称为primary，secondary
所以，一台标准PC最多可连接四个IDE设备，
如果要连接更多的IDE设备，除非主板上有特制的
IDE子系统，否则就要安装额外的IDE适配器次啊可以


磁盘设备

对于IDE设备，linux默认的设备文件定义：

/dev/hda  Primary master IDE(通常接硬盘)
/dev/had  Primary slave IDE
/dev/hdc Secondary master IDE(通常接光驱)
/dev/hdd  Secondary slave IDE



SCSI 设备文件也是类似，但是没有四个设备的限制：

/dev/sda  第一台SCSI设备
/dev/sdb  第二台SCSI设备
...


SATA硬盘的设备文件采用与SCSI相同的命名惯例

应考诀窍


如何依据设备文件的名称来区分磁盘接口是IDE,SCSI



磁盘分区


几乎每种操作系统都可让你将硬盘划分成多个逻辑河北，
也就是所谓的"分区"(partition)
磁盘的划分情况记录在"分区表"(partition table)中。
分区表的格式随计算机型号和操作系统而异


linux支持多种分割格式，但默认使用MS-DOS格式
这种格式允许你将磁盘最多划分成四个"主分区"(primary partition)
或是三个主分区加一个"扩展分区"(extended partition)

扩展分区可被区分成最多12个"逻辑分区"(logical partition)


一个硬盘最多可划分成15个可用的分区

每一个分区(无论何种类型)都有一个对应的设备文件，
其文件名为所属硬盘的设备文件名加上分区编号。
主分区与扩展分区的编号范围为1～4,逻辑分区则从5开始编号


例如，你的IDE硬盘是以master模式接在primary接口(设备文为/dev/hda

它被划分有两个主分区与一个扩展分区，扩展分区本身又被
划分成3个逻辑分区，则各分区对应的设备文件为：

/dev/hda1 (主分区#1)
/dev/hda2 (主分区#2)
/dev/hda3 (扩展分区)
/dev/hda5 (逻辑分区 #1)
/dev/hda6 (逻辑分区 #2)
/dev/hda7 (逻辑分区 #3)

假设有一块SCSI硬盘(或SATA硬盘)
它被划分有一个主分区与一个扩展分区，扩展
分区又被划分成两个逻辑分区，则各分区对应的设备文件如下：

/dev/sda1 (主分区#1)
/dev/sda2  (延伸分区)
/dev/sda5 (逻辑分区#1)
/dev/sda6 (逻辑分区#2)

要熟记各种分区(主要，扩展，逻辑)的编号原则


各家操作系统都提供了分割磁盘驱动器的工具，
Linux系统所提供的工具为fdisk.

每个分区可以各自容纳自己的文件系统，而制作
文件系统的工具是mkfs


根文件系统与挂载点

分区上的文件系统必须被挂载到"目录树"(directory tree)上的某个节点---
称为挂载点(mount point)
挂载点跟普通目录没有不同，只不过它们是用来作为分区(文件系统)的入口。
在未挂载之前，挂载点目录下通常是全空的


目录树的最顶层称为"根"，以/符号表示，它是一个很特殊的挂载点。
当Linux系统开机时，会优先挂载"根文件系统"(root filesystem)
然后才依据/etc/fstab来挂载其他文件系统。至于根文件系统在哪一个分区，
则由Linux内核的开机参数root决定(通常由LILO或GRUB来提供root参数值)


理论上，根文件系统可以包含整个目录树，事实上，许多小型系统也是如此

不应该将所有数据都放在同一个文件系统中。在实践中，常将不同性质的目录分别
对应到不同的分区，甚至是不同磁盘的分区。


至于哪些目录应该放在独立的分区，涉及个人习惯与专业上的据诶到哪个，

/(根目录)
	由于开机过程之初只会挂载根文件系统，所以有些重要目录必须放在此分区，
	系统才能顺利开机。这些必要的目录包括：
	/bin与/sbin 包含必要的系统二进制二建
	/dev 设备文件
	/etc  几乎所有配置文件都在此目录下
	lib   执行/bin与/sbin下的程序时所需要的公共函数库

/boot 
	此目录含有boot loader所需的静态文件，包括kernel image(内核镜像)
	在实践中，常将/boot放在磁盘上的第一个分区，避开BIOS 1024-cylinder的限制


/home

	此目录主要用户存储用户的个人文件。由于是主要工作区，经常变动，而且
	可能需要庞大的存储空间，这些理由使得/home常被防止在独立的分区，
	甚至是独立的实体磁盘或磁盘阵列。不过，对于某些类型的服务(如防火墙)
	此目录也可能不重要


/tmp
	/tmp主要用来存放临时性文件。虽然所需的空间不是很大，但由于其
	权限是完全开放的，所以常被放在自己的专属分区，以免有人恶意在
	/tmp下产生超大文件，而排挤了其他文件系统的可用空间



/var
	此目录专用来存放经常变动的文件，比如日志文件。基于与/tmp同样的
	安全考虑,/var也常被放在独立分区，以免因为忘了定期清理日志文件，
	而排挤了其他文件系统的空间

/usr
	这是一个庞大的目录树，其中包括用户的工具程序，
 	应用程序(/usr/bin, /usr/sbin)
	源程序(/usr/src)
	文件(/usr/share/doc)等
	由于所需的空间相当大，所以也经常被放在独立分区。这样做的一个好处
	由于/usr/目录下的信息几乎都是静态不变的，所以有些管理者
	偏好以只读模式来挂载它，以避免它遭到毁坏。

除了以上6个分区，linux还需要一个swap分区以启动虚拟内存。
swap分区的大小通常是系统内存常量的两倍


在安装Linux系统的期间，上述原则可以帮你规划磁盘分区，
假设一台文件服务器，这台及其有两块IDE硬盘(/dev/hda与/dev/hdc)
容量分别为40GB,80GB

文件服务器的磁盘划分实例



分区             类型             文件系统            容量
/dev/hda1        主要            /boot                512MB
/dev/hda2         主要             /                4GB
/dev/hda3       扩展                                   35.5GB
/dev/hda5        逻辑             /usr               20GB
/dev/hda6       逻辑               /tmp               512MB
/dev/hda7      逻辑                /var                  13GB
/dev/had8      逻辑               swap                   2GB
/dev/hdc1      主要               /home                  80GB


管理分区


对于磁盘驱动器的划分，Linux提供的标准工具是fdisk,另一个是cfdisk.

前者是每家linux版本都提供的文本模式的程序，后者以curse函数库写出来的TUI
菜单式工具。

fdisk

语法
	fdisk [option] device

说明

fdisk 可显示或编辑特定磁盘的分区表(partition table)
它提供一个简单的文本操作接口

fdisk /dev/sda

常用指令

a   改变某分区的bootable标记。习惯上，对第一个主要分区(或是要挂载
	在/boot的分区)应该设立此标记

d  删除一个分区。fdisk会雯你要删除哪一个分区。如果删除扩展翻去，则所有
	逻辑分区会跟着小时；若删除某逻辑分区，则其后的逻辑分区编号将
	往前递补，以维持逻辑分区编号的连贯性

l 列出已知的分区类型与系统标识符


m 显示出指令列表

n 新增一个分区。fdisk会依序问你一下问题：
	分区的类型(primary,extended 或logical)
	分区的编号，起始磁柱(cylinder)的编号，结尾磁柱的编号。
	主分区与扩展分区的编号范围为1~4,逻辑分区从5开始编号。
	输入结尾磁珠的编号时，可以输入"容量值"来代替(例如 "+512M")
	fdisk会依据你给的容量值自动算出结尾磁柱的编号。	
	对于新建的好的分区，fdisk会自动将其类型代码设定为83(Linux native)
	如果该分区要作为swap或是要用于其他操作系统，则必须以t指令来变更
	分区的系统标识符


p   显示内存中的分区表(partition table).如果你所做的变动尚未写回
	磁盘，则你所见到的状态将不同于实际存放在磁盘上的分区表



q 不修改分区表而直接离开fdisk。除非事前以w命令将内存中的分区表写回
	磁盘，否则你所做的改变会消失



t 变更分区的系统标识符(system ID).这是一个十六机制的数字，代表分区
	所含文件系统的类型。Linux分区的系统标识符为83，而Linux swap
	分区的系统标识符为82

w  将内存中的分区表写回磁盘。在此命令之前，你所做的任何改变都不会
	影响磁盘上的分区表



范例


1.显示 /dev/sda上现有的分区表，不做任何变动


fdisk /dev/sda


面对的/dev/sda是一个大容量的200GB磁盘，磁柱有三个主要分区(sda1~sda3)
其中前两个是用于Linux系统，第三个（sda3)是用来安装Windows系统
(从其系统标识符HPFS/NTFS可看出来)
sda4是扩展分区，它占有其余的可用空间；sda5~sda8都是逻辑分区(它们都是
sda4扩展分区的一部分)，其中sda7被用来作为Linux swap


2.从空的分区表开始，在/dev/sdb1 上创建一个300MB的引导区；在/dev/sdb2
创建一个涵盖整个硬盘其余空间的扩展分区；在/dev/sdb5创建一个200MB
的逻辑分区;在/dev/hda6 创建一个128MB的swap分区；
最后将其余空间都分配给/dev/hda7 逻辑分区

fdisk /dev/sdb

在操作过程中，fdisk会给你提示默认值，如果接受，直接按Enter即可。
若需要指定容量，可以使用类似+128M之类的格式，其中M代表megabytes



警告


使用Linux版fdisk工具来制作其他操作系统的分区，可能会遇到一些问题。
原则上，要给什么操作系统用的分区，就应该尽量以该系统的工具来制作


对运作中的系统使用fdisk可能会导致危险。
要被修改分区表的硬盘上不应该有任何分区被挂载咋系统上。
否则，按下w指令之后可能会让你的磁盘崩溃


应该了解分区表，分区的编号方式，并且熟悉使用fdisk创建分区的过程


创建文件系统

对于刚划分好的磁盘分区，必须先安装文件系统才可以供Linux使用。
以Windows的，“安装文件系统"就是"格式化"(formatted)


不同类型的文件系统各有其专属的格式化工具。
例如，ext2,ext3文件系统的制作工具是mkfs.ext2与mkfs.ext3(其实它们
是mke2fs的符号链接):
resiserfs文件系统的制作工具是mkreiserfs.有一个统一的前台工具，
Linux提供了mkfs工具，它会依据指定的文件系统类型，
帮你调用正确的工具来制作文件系统


mkfs
语法

	mkfs [-t fs_type] [fs_options] device



说明


在device 上建立fs_type类型的文件类型。若没有明确指定fs_type,
则默认值是ext2.当mkfs启动对应的格式化工具时，会将你指定的fs_options
传递给该程序。




常用的fs_options选项


-c  检查device是否有故障块。mke2fs与mkdosfs适用
-L label   设定文件系统的卷标(volume label) .仅mke2f适用，对于
	 mkdosfs,此选项要改成-n,而且lebel不得超过11个字符
-q
	抑制执行过程所产生的信息
-v

	详尽显示执行过程中的每一个步骤。适用于mke2fs与kdosfs

范例


1.将/dev/sdb1 分区格式化成ext2文件系统，执行过程尽量低调(不输出详细信息)

mkfs -t ext2 -q /dev/sdb1



2.将/dev/sdb1分区格式化成ext3文件系统，将卷表设定为modisk,
格式化过程要检查故障块并产生完整而详细的输出信息



mkfs -t ext3 -L modisk -cv /dev/sdb1


不同文件系统的格式化工具各有其专属的微调选项，

制作swap分区


每一个正常运作的Linux系统都至少应该有一个swap分区，
这个特殊的分区不被挂载到目录树，而是被当场虚拟内存使用，
制作swap文件系统的工具是mkswap


mkswap


语法
	mkswap device


说明
将指定的分区或文件格式化成交换分区


范例


假设/dev/hda5是一个系统标识符已被设定为82(Linux swap)
的分区，下列命令可以将它格式化为交换空间


mkswap /dev/hda5


事实上，Linux的交换空间不一定要放在独立分区，也可以先准备一个够大
的文件，


然后用mkswap制作此文件的格式


mkswap swapfile


制作好交换分区格式之后，还必须用swapon命令让交换分区生效


swapon /dev/hda5

或

swapon  swapfile

警告


fdisk,mkfs的磁盘工具，对于磁盘数据的破坏力很大，不要搞错！


104.2   维护文件系统的完整性



任何长期运作的操作系统，包括linux在内，文件系统都会渐渐出现出现一些问题：
1.存储空间耗尽，造成某些程序甚至整个系统瘫痪
2. 数据结构损毁，可能是因停电，不当操作或任何无法预料的意外
3. 耗尽所有的inode,以至于无法创建新的文件或目录(及时还有存储空间)


避免问题的不变法则，就是定期的监控与检查。Linux提供一系列工具
帮助你避免，修复文件系统的问题


监控可用的磁盘空间与inode数量

一个可供读写的文件系统有可能不能再继续容纳新文件，这可能是由于存储
空间耗尽或没有剩余的inode可用



Inode是文件系统中的数据结构，用以记录文件的属性，像是位于磁盘中的
位置，拥有者为谁，所属组，访问权限等。
当你使用mkfs制作文件系统时，其实就是将inode的存储区写入磁盘，
文件系统对的inode数量是有限的，而inode的数量也就是文件系统
所能容纳的文件数量的上限。几乎所有文件系统在建立时都会预先设置大量的
inode,所以耗光inode的机会并不多，比较可能发生的情况是同一个分区装填了太多
小文件才会发生这种现象


避免系统分区发生存储空间耗尽或inode不足的下新娘，是系统管理员平时就要
担负的责任。
df 可提供该磁盘空间用量与inode用量


如果耗尽磁盘空间，最简单的解决方法是删除文件或将文件移动到
其他文件系统(不一定可行)
遇到inode不足，那么除非能够删除大量文件，否则所腾挪出来的
inode数量还是有限的


df 
语法
	df [options] [dirs]


说明
显示dirs所属的文件系统的磁盘空间用量。dirs可以是任何目录，df会
依据/etc/fstab配置文件找出dirs的挂载点，然后显示对应文件
系统的信息。若没有指定任何dirs，则df会显示所有已挂载的
文件系统的嘻嘻

常用选项


df -h  以较容易辨识的单位(如M,G)显示数值
df -i 显示inode用量的信息。若不指定此选项，则显示磁盘空间用量


范例

1.查看所有文件系统的磁盘空间用量


df -h

所有文件系统的用量都不超过5成，表示这个系统还有足够的存储空间


2. 查看所有文件系统的inode用量

df -i


例子中，inode用量最多的是/usr文件系统，


3. 查看当前工作目录位于哪个分区

df .

监控磁盘用量
在linux下，du可用于显示个别目录的磁盘用量，搞清楚磁盘空间被哪些目录
消耗掉


du

语法
	du [options] [directories]

说明


显示directories的磁盘使用信息。如果省略directories,则显示当前工作目录的用量


常用选项

du -a 显示所有文件，而不只是目录
du -c  累计所显示的项目的总用量
du -h  以适合研读的单位(如M,B) 来显示数值
du -s  仅显示出指定目录本身的摘要信息，而不是递归显示每个子目录
du -S 子目录的用量不列入计算



范例


1.查看/etc/rc.d的磁盘空间用量


du /etc/rc.d


2. 显示/etc 的磁盘空间用量，包括其下的子目录

du -sh /etc

3. 显示/etc 的磁盘空间用量，但不包含其下的子目录


du -Ssh /etc


4. 找出谁好用了最多的个人目录(/home/*) 空间：

du -csh /home/* | sort -nr 

例子中的表示用户lin郝勇了最多的磁盘空间。
若加上-h选项，那么sort的排序结果将不是你所设想的那样，因为sort
在比较数值大小时不会将单位也计算进入

调整文件系统参数

有许多情况使得管理者想要修改现有文件系统的参数。
例如，某个文件系统的用途改变了，你可能会想要改变其卷标(volume label)
使用tune2fs可以修改ext2与许多其他文件系统的参数


tune2fs

语法
	tune2fs [options] device

说明
修改device 上的ext2或ext3文件系统的可调用参数


tune2fs -l device
	列出device 上的可调参数
tune2fs -c n
	设定足底啊挂载次数为n.当文件系统的挂载次数超过此限制，而文件
	系统再次被挂载时，内核会剔除警告并对此文件系统自动执行e2fsck -p
	(此命令在每次开机时会被自动执行一次)
	若将此值设定为0,表示希望内核忽略此上限度

tune2fs -i n

	设定量词文件系统检查之间的最长间隔时间。若n为纯数值或是其后表示了一个d,
	则解释为"天数"(默认为180天)，若后缀单位为w,则代表"周数";	
	m代表"月数"

tune2fs -L label
	设定文件系统的卷标(volume label).若你的/etc/fstab以卷表来描述
	分区，则必须修改/etc/fstab使其符合现况，或改以设备名称
	(/dev/hda1 之类的名称) 来描述分区


tune2fs -j
	增添一个ext3变动历程文件(journal file)到文件系统并设立has_journal功能标记



tune2fs -m n
	设定保留块的比例为n.在默认情况下，ext2为root管理员保留总块数的5%,
	这表示若某个文件系统有95%都快填满了，则只有root能继续写入数据到该文件	
	系统。这同时意味着着，对于一个用量超过95%的文件系统，df汇报的用量将为100%

	对于非常庞大的文件系统或纯粹专供用户写入数据的文件系统，可以安全地缩减
	保留块的数量，以提供更多存储空间


tune2fs -r n
	设定保留块数为n.此选项的效果类似于-m,只不过它设定的是块数，而
	非比例数

范例


1.列出/dev/hda8de superblock的内容


tune2fs -l /dev/hda8


2. 将/dev/sdb2 的挂载次数上限与检查间隔时间都关闭(归零)


(先查看旧设定值)
tune2fs -l /dev/sdb2 | grep "Maximum mount count"


tune2fs -l /dev/sdb2 | grep "Check interval"


(检查新设定值)


tune2fs -l /dev/sdb2 | grep "Maximum mount count"


tune2fs -l /dev/sdb2 | grep "Check interval"



检查并修复文件系统


意外断电可能导致文件系统出现不一致的现象，管理者必须要予以修复，以
确保日后文件系统的可靠性

不同的文件系统有各种各自专用的检查工具，如mkfs

为了一致，linux提供了一组共同的前台工具，fsck(包括fsck.ext2,fsck.ext2..)
它们会被链接到实际的检查工具(e2fsck)


注意

e2fsck也可以检查ext3文件系统。当发现ext3文件系统没有被干净德卸载，
它会先补全变动记录，然后像平常检查ext2那样来检查ext3文件系统

写入磁盘的数据中有一部分用来描述文件系统的，这些重要信息存放于superblock,
也就是每个分区的第一个块。由于superblock很重要，
所以每固定块数的块中就有一个块被用来存放superblock副本。
以ext2与ext3为例，每8192个块便有一个superblock
编号1,8193,16385...的块都是superblock.
当文件系统出错时，就不保证#1 superblcok的内容的一定正确，
而fsck可依据事先备份的superblock副本来恢复主要的superblock(#1)

fsck

语法
	fsck [options] [-t type] [fs-options] filesystems


说明

检查文件系统的错误并执行用户指定的修复选项。
若没有以-t选项指出文件系统的类型，fsck会假设要被检查的文件系统类型为ext2
在默认情况下，当fsck找到问题时会提示一段信息，让用户决定要如何处理


fsck的常用选项

fsck -A
	检查/etc/fstab文件中所列的文件系统。本选项主要用于开机期间，	
	在挂载文件系统之前。

fsck -N
	不实际执行修复工作，只显示会做出哪些动作


fsck -t type
	指定要被检查的文件系统的类型，默认为ext2.fsck依据type
	来判断应该调用哪一种文件系统的检查程序


e2fsck 的常用选型


e2fsck -b superblock
	让e2fsck知道哪一个superblock的内容是可以相信的。在交互模式下，
	e2fsck会自动判断应该采用哪一个superblock.
	在批处理模式下，则通常会选择8193作为修复主要superblock的依据


e2fsck -c
	检查块是否实体受损


e2fsck -f
	强制进行检查，即使文件系统看起来受损

e2fsck -p	
	自动修复文件系统，而不征询用户的同意


e2fsck -y
	自动对所有提示问题"yes".当文件系统上有许多错误时，你可能会被迫
	回答一大堆"yes"

范例


1.检查/dev/hda5 (尚未被挂载) 上的ext2文件系统：

fsck /dev/hda5


例子中分区是洁净的(clean),也就是没有首都内，所以fsck没有
真正进行任何检查动作


2.强制进行检查


fsck -f /dev/hda5

3.强制进行另一次检查，这次会产生冗长详细的输出信息


fsck -fv /dev/hda5


4.使用-y 选项让fsck自动修复受损的文件系统：


fsck -y /dev/hda5


当linux开机时，开机脚本会自动对/etc/fstab所列的每一个文件系统执行一次
fsck -A,借此检查并修复先前未被妥善卸载的文件系统。
如果检查时发现严重错误而需要管理员介入时，系统将会进入单用户模式(single-user


要熟练  du,df,fsck


104.3 控制文件系统的挂载与卸载

Linux的目录树由各磁盘上的各分区共同构成。即使是可插入式储媒(光驱，软驱)
上的文件系统，也是以类似的方式整合进目录树。
每个文件系统在目录树中都各有自己的空间，称为"挂载点"(mount point)


挂载点通常是空目录，在未挂载文件系统之前，挂载点底下没有任何文件或子目录。
如果你将文件系统挂载到一个非空目录，则该目录的原有内容会暂时小时，直到文件
系统被卸载为止


习惯上，/usr,/home,/var,/tmp会因为特殊考虑而独立于各自的分区，而可插入式
储媒的挂载点则是集中在/mnt或/media的子目录，
例如/media/cdrom , /mnt/floppy等


管理文件系统配置(/etc/fstab)

由于Linux目录树可能横跨多个磁盘上的多个分区，所以必须要有一个机制，
使Linux可在启动时自动挂载各分区，此机制便是记录在/etc/stab
配置文件里的"文件系统配置表"。事实上，/etc/stab不不仅记录了
如何挂载本机磁盘驱动器的信息，插入式储媒与远程网络磁盘(NFS,SMB)
的挂载信息也是记录在此文件中。

/etc/fstab是一般的文本文件，每一行各描述一个文件系统的挂载信息，
这些信息由下列6个字段组成：


1. 设备(device)

	持有文件系统的设备文件的名称。例如/dev/hda1
2.挂载点(mount point)

	用于挂载文件系统的目录。习惯上，含有/etc,/bin等重要目录的根文件	
	目录根文件系统，其挂载点是/:
	含有/var/log , /var/spool等市场变动数据的文件系统，其挂载
	点是/var;含有/usr/bin, /usr/src,/usr/sbin
	等重要程序目录的文件系统，其挂载点是/usr
	含有kernel image的文件系统，其挂载点是/boot

3. 文件系统的类型(filesystem type)

	文件系统的格式。可能的格式包括ext2,ext3,reiserfs(一般硬盘分区)
	swap(交换分区)，iso9660(光盘),msdos(软盘)，vfat,ntfs(windows
	的分区)等

4. 挂载选项(mount option)
	此字段由一系列以逗号分隔的选项构成。可用的选项随着文件系统的类型而定

5. 备份频率(dump frequency)

	dump 程序(Unix的标准备份工具之一)会参考此字段的值，借此判断各文件
	系统的备份频繁度。此字段的值是一个整数，通常，linux的原生文件系统
	(ext2,ext3,reiserf等)是设定为1，其他文件系统(iso9660,
	vfat,msdos...)则设定为0


6. 遍(pass)

	此字段代表启动期间自动检查文件系统时的次序，也也就是传给fsck -A
	参数值，有效值为0，1或2的其中之一，
	0表示不检查，1代表优先检查，2代表所有有限次序为1的文件系统
	都检查过之后才予以检查。
	习惯上，根文件系统的检查次序为1;其他会被自动挂载的文件设定为2
	不自动挂载，可插入式储媒以及远程文件系统则设定为0


范例

1. /etc/fstab 配置文件的实例


例子中的计算机有两块SCSI磁盘，其中/dev/sda是存放操作系统的，而/dev/sdb
主要是供使用者存放数据。最后一个项目(/mnt/fs)是远程的Samba(或Windows)文件系统

在安装linux系统的过程中，安装程序会依据磁盘驱动其的划分现况来自动创建/etc/fstab
配置文件。如果安装了新硬盘或是需要连接远程驱动器。
管理者可在事后修改此配置文件，使其符合最新的实况需求


熟悉/etc/fstab文件的每个字段的功能

挂载文件系统

除了在启动期间自动挂载文件系统之外，也可以使用mount命令与系统运作期间挂载
文件系统


mount

语法
	mount [command_line_options] device
	mount [command_line_options] directory
	mount [command_line_options] device directory


说明


mount 将指定的文件系统(位于device) 挂载到目录数上的特定挂载点(directory)
让用户可透过挂载点访问对应的文件系统。mount有两个必要参数(device与directory),
若指定其中之一，mount会自动到/etc/fstab取得其余不足信息，
但如果两个参数都提供了，则不参考/etc/fstab配置文件


命令行选项


mount -a 
	挂载/etc/fstab配置文件所列的所有分区，但是有noauto选项的分区除外

mount -h 
	显示辅助说明信息

mount -o mount options
	挂载选项
mount -r 
	以只读模式挂载文件系统

mount -t fstype
	指定目录文件系统的类型。这项信息通常可以从/etc/fstab配置文件取得，
	但是对于/etc/fstab没有记录的文件系统，则必须明确指出其文件
	类型，内核才能以正确方式来访问文件系统



mount -v
	设定verbose(冗长) 模式


mount -w
	以可读可写模式挂载文件系统


挂载选项

挂载选项通常是定义与/etc/fstab配置文件的第四个字段，但是也可以用-o
命令行选项来指定，不同类型的文件系统有各自适用的挂载选项，但是
大多数选项是通用的，分别为：


async
	以异步模式访问文件系统。相反选项是sync

auto	
	使用-a命令行选项时可被自动挂载。相反选项是noauto

defaults
	相当于同时指定rw,suid,dev,exec,auto,nouser与async这些选项

dev
	解释文件系统上的字符(character) 或块(block) 特殊设备

exec
	允许执行挂载分区上所含的程序。相反选项是noexec


noauto
	使用-a命令行选项时不可被自动挂载。通常应用于插入式储媒

noexec 
	不允许执行所挂载的文件系统上的程序文件(通常是基于安全考虑)
nosuid
	不允许可执行文件的suid与sgid位的作用生效


nouser
	禁止一般用户挂载或卸载此文件系统。相反的选项是user与users

ro
	相当于 -r 命令行选项

rw
	与-w命令行选项等效

suid
	允许可执行文件的suid或sgid位的作用生效

sync
	以同步模式访问所挂载的文件系统。相反选项是async

user
	允许一般用户挂载此文件系统，但禁止其他人(一般用户)卸载它。
	通常用于可插入式储媒


users
	允许任何用户挂载，卸载此文件系统


user与users选项可让一般用户执行mount与umount命令。
对于需要让终端机用户可挂载插入式储媒的系统，很重要

文件系统类型

Linux可挂载多种文件系统，所以mount命令必须知道所要挂载的文件系统的类型，
此参数可能以命令行选项-t来指定，或定义于/etc/fstab配置文件的第三个字段，

最常见的文件系统类型：


1.ext2,ext3

	Linux的标准文件系统


2.reiserfs,xfs
	具有变动记录功能(journal)的高效率文件系统，在服务器领域很流行

3.msdos,vfat
	msdo是MS-DOS FAT文件系统，限用"8.3"格式的文件名称，后者
	全名为Virtual FAT,支持长文件名的加强版FAT文件系统

4. iso9660,udf

	ISO-9660 是CD-ROM的标准格式。UDF是packet-writing可刻录
	的标准格式。


5. nfs,smbfs
	NFS服务器，Samba(Windows) 服务器

6. swap
	交换分区
7. proc

	Linux内核虚拟出来的一个文件系统，它不对应到任何磁盘分区。
	主要用途是提供内核的运作状态，供系统软件访问(或改变)系统配置

范例

1.显示系统上当前所安装的文件系统

mount 


例子中，可以看到许多不同类型的文件系统，包括内核虚拟出来的proc,
sysfs,udev,devpts,./dev/shm,还有实际对应到磁盘分区的/,/usr,/var
/home,/tmp以及用户插入式储媒的/mnt.cdrom ,USB

2.以只读模式将接在/dev/hdc的ATAPI CD-ROM 挂载到现有的/cdrom 目录

mount -rt iso9660 /dev/hdc /odrom

若没有明确指定-r选项，则mount会试着以R/W模式来挂载光驱，但由于光驱
本身是只读设备，所以mount会提出警告信息，然后以只读模式来挂载光驱


mount -t iso9660 /dev/hdc /mnt/odrom


3.将在第一个软驱/dev/fd0(在MS-DOS操作系统中为A:)中的MS-DOS软盘挂载
到现有的/floppy目录上

mount -t msdos /dev/fd0 /floppy

4. 假设挂载到/home与/opt 上的文件系统已经被卸载(为了进行定期维护工作)
现在要将它们挂载回来

mount -av

使用mount -a时，它会安全地劈开先前已经挂载的文件系统


卸载文件系统

用于卸载文件系统的命令是umount,但文件系统被卸载之前，应该存储在该文件系统
但仍留滞在内存缓冲区的数据会被全数写会磁盘-----这项作业称为"同步"(sync)
然后才解除挂载点与文件系统的配对关系

若将要被卸载的文件系统上仍有尚未关闭的文件或是有任何进程的工作目录
仍留在该文件系统，umount将拒绝卸载


对于已经被挂载的可插入式储媒(比如，软盘，ZipDrive,USB Drive。。。)
若未先卸载就抽离储媒，要报错


umount 
语法
	umount [options] device
	umount [options] directory


说明
卸载位于device的文件系统或被挂载在directory的文件系统


umount -a 自动卸载/etc/mtab所列的所有文件系统，本选项通常用于关机脚本。
	/etc/mtab文件是由mount与umount自动维护，其中记录了现有
	文件系统的挂载情况


umount -t fstype
	仅卸载fstyle 类型的文件系统


范例

1. 卸载/cdrom 目录上所挂载的/dev/hdc光驱

umount /cdrom  或  umount /dev/hdc

2. 卸载所有NFS文件系统


umount -at nfs

要知道mount,umount命令的用法，挂载点(mount point)的意义
以及/etc/fstab中各字段的意义


104.4  管理磁盘配额


磁盘空间的管理很重啊哟，磁盘空间是有限的资源，而且消耗速度往往很大，
在多用户操作系统上，不论磁盘空间有多充裕，用户都会填满它
管理员要避免磁盘空间被太早填满。避免磁盘空间被耗光的最有效手段，
就是实施磁盘配额(disk quota)政策，限制个别用户或组的磁盘空间耗用量


典型的配额量通常小于文件系统的整体容量，以免用户或组耗用太多磁盘空间，
理论上，对记录于/etc/fstab里的每个文件系统都可以限制其配额，
实践中，只有会同时被多用户消耗的文件系统，例如,/home,/tmp
才有限制配额的必要。
限制/usr的配额没有太大以，因为一般用户不会将文件存放在该处


配额的限制对象可以是/etc/passwd所列的每一位用户或是/etc/group所列的
每一个组


设定配额系统

linux的配额系统由内核，文件系统,/etc/fstab配置文件以及相关工具组成。

设定/home文件系统的用户与组的配额，而该文件系统位于/dev/sda6

可以只启用用户的配额，组的配额或两者同时启用


注意

配额功能需要Linux内核的支持。几乎所有Linux distribution随附的内核都支持
配额，但如果你用的内核刚好没有，需要重新编译一个新内核。
Linux内核的编译与安装是102的考试范围
要想确认你用的Linux内核是否支持配额，最简单的方法是查看dmesg输出的信息
是否含有"quota"字符串

dmesg | grep -i quota


1. 编辑 /etc/fstab配置文件，在需要配额限制的文件系统(例如/home)的挂载选项
栏补上 userquota 或grpquota


userquota表示该文件系统要对"个别用户" 实施丿和管理
grpquota 表示配额管理的对象是"组" 。同时标注这两个选型，
表示同时这两种对象实施配额管理

2. 在需要管理配额的文件系统顶层(例如/home)创建quota.user 与
quota.group文件，并将它们设定成只有root可以访问、

touch /home/quota.user /home/quota.group


chmod 600 /home/quota.user /home/quota.group


如果想让你一般用户也能够查看自己的属组的配额状况，quota.group文件的访问
模式应该是644或640 ，而非600
quota.user 与quota.group这两个文件合称"配额数据库"，它们的作用是记录该文件系统
的配额状态，其中quota.user记录个别用户的配额，而组的配额是记录在quota.group中
每个有配额管理的文件系统都有它们自己的配额数据库

3. 使用edquota设定配额

4. 执行quotacheck，将配额数据库编译成二进制格式：

quotacheck -avug

还没有设定任何配置限制。限制可以用ls查看配额数据库文件


ls -al /home/quota.*

有些系统的配额数据库是放在其他文件中的

ls -l aquota.*

5. 执行quotaon,让配额限制开始生效


quotaon -a


6. 设法让系统在启动时自动启动配额系统。你的系统上应该有现成的rc.scripts可用
(/etc/rc.d/rc.sysinit 或/etc/init.d/quota)

用grep 对/etc/rc.d或/etc/init.d/用户下的文件搜索"quota"字样
应该可以帮助你判断哪一个脚本有启动配额系统的功能。如果
没有，写一个适合你系统的rc.script

if [-x /sbin/quotacheck]
then
	echo "Checking quotas."
	/sbin/quotacheck -avug
	echo "Done."
fi
if [-x /sbin/quotaon]
then
	echo "Turning on quotas."
	/sbin/quotaon -avug
fi


7. 设法让系统定期执行quotacheck,使其自动更新配额数据库。典型做法是写一个
	cron script,放在每日或每周例行工作的目录下(/etc/corn.daily
	或/etc/cron.weekly)


#! /bin/bash
/sbin/quotacheck -avug


也可以(使用crontab -e命令)将 /sbin/quotacheck写入root的crontab文件

使其定期执行:
03 ** 0 /sbin/quotacheck -avug

现在，挂载在/home的文件系统已经可以为每个用户与每个组实施配额管理并汇报
配额状况

要对配额系统的运作有个整体概念，相关工具的功能。
配额是针对"个别文件系统"(per-filesystem basis)来设置的


配额限制

对于每个文件系统，都可以实施5种配额限制。配额量的计算单位是”磁盘块“(disk block)
通常一个块的大小等于1024bytes

个别用户的硬性限制(per-user hard limit)
	个别用户可拥有的磁盘容量的绝对上限。若超过此限制，用户将无法继续吸入新数据到
	磁盘

个别用户的软性限制(per-user soft limit)
	个别用户可以自由运用而不会出现任何警告信息的容量限制。若耗用量虽超过次子安置
	但尚未超过硬性限制。则用户仍可写入新数据，但会收到警告信息

个别组的硬性限制(per-group hard limit)
	个别组可拥有的磁盘容量的绝对上限。若到达此限制，组成员将无法继续
	吸入新数据到磁盘，即使个别用户还有没用完的配额


个别组的软性限制(per-group sort limit)
	个别组可以自由运用而不会出现任何警告信息的容量限制。若耗用量虽
	超过此限制但尚未超过硬性限制，则组成员仍可以写入新数据，
	但是所有成员都会收到警告信息


宽限期(grace period)
	一旦数据量到达了软性限制，相关用户或组就开始进入"宽限期"。
	在这期间，用户或组必须清理文件，将耗用量降到软性限制之下，	
	若已经超过宽限期但还没有腾挪出足够空间，则软性限制会
	变成硬性限制。
	宽限期的单位可以是months,weeks,days,hours,minutes,seconds
	典型的宽限期是7天(7 days)


设定配额的命令是edquota


注意

当耗用量超过硬性限制或是软性限制的宽限期已过，而耗用量还没有降到
软性限制之下，则写入磁盘的数据可能不完整。
超过限制的部分会被硬生生截断，留下不完整的文件。倘若磁盘
写入操作是发生在shell的非交互模式下，正在执行shell script,
则用户可能会错过警告信息，而应用程序或shell script会提出
磁盘空间已满或文件有写保护(write-protected)之类的信息


管理配额的工具


linux提供了一套可用来管理，显示与汇报文件系统配额的工具。

quota

语句
	quota [-u] [options] user
	quota -g [options] group


说明


显示user或group的配额限制。若不指定-u与-g选项，quota默认会显示用户
个人的配额情况(相当于-u选项)。只有root可以同时使用-u与user来查看
其他用户的配额情况，一般用户只可查看的配额限制或以-g与group来
查看所属组的限制

常用选项

quota - q
	安静模式。只有在超过配额时才会显示信息

quota -v
	详尽模式。即使未配置任何空间，也会显示信息


范例

1. 以root身份查看用户bill的配额现况

quota -uv bill


用户bill在/dev/sda6的软性限制(10000个块)几乎超过，而相应的
硬性限制有10200个块，grace字段(宽限期)并未显示任何值，是因为
尚未超过软性限制


2. 以用户joe的身份查看自己所属组finance的配额

quota -gv finance

finance组的空间耗用量已经超过其软性限制(990个块)，而且正好
用到硬性限制的100个块(写入第1000个块的操作或许并未完成)
grace字段的原始值是7,而限制只剩下6天了
这表示从超过软性限制当天算起，已经过去1天



quotaon

语法
	quotaon [option] [filesystem]
	quotaon [options] -a

说明
开始对指定的文件系统实施预先设定的配额限制

常用选项

quotaon -a
	对/etc/fstab配置文件中有资格的所有文件系统启动配额限制。
	所谓"有资格"是指文件系统必须是可读可写的，
	而且挂载选项字段有usrquota或/且grpquota选项
	启动脚本通常会以quotaon -a 命令来让配额系统生效


quotaon -g 
	使组配额限制生效。使用-a选项时无需指定本选项，因为-a是更广义的-g
quotaon -u
	让用户配额限制生效。这是默认选项
quotaon -v
	详细显示每个文件系统的配额情况


范例

1. 让/etc/fstab中定义了配额的文件都生效


quotaon -av

2. 仅让/home 文件系统的组配额限制生效


quotaon -gv /home

qutoaoff

语法

	quotaoff [options] [filesystems]
	quotaoff [options] -a

说明
让指定的文件系统的配额限制失效

常用选项


quotaoff -a
	关闭/etc/fstab配置文件中定义过的所有文件系统的配额限制

quotaoff -g
	关闭组配额限制。使用-a选项时就不必使用本选项


quotaoff -u
	关闭用户配额限制，这是默认值
quotaoff -v
	详细显示每个文件系统的配额情况


范例
1. 取消所有配额限制


quotaoff -av


quotacheck

语法
	quotacheck [options] filesystems
	quotacheck [options] -a


说明

检查文件系统并编译配额数据库。这是Linux配额系统中一个重要组件，
应该以cron定期指定quotacheck -a命令

常用选项

quotacheck -a 
	检查/etc/fstab配置文件定义的所有文件系统的配额。
	若挂载选项中同时出现usrquota与grpquota，则用户
	与组的配额都会被检查并重新编译

quotacheck -g group
	仅编译特定组信息
quotacheck  -u user
	仅编译特定用户的信息(默认行为)

quotacheck -v 
	详细显示执行过程与进度


范例

1.初始化所有的配额文件

quotaoff -a
quotacheck -aguv


进行更新之前应该先关闭配额系统，等完成检查之后再重新开启


2.在配额限制有效期间更新内存中对于/home 的用户的配额数据


quotacheck -v /home


edquota

语法

	edquota [-p proto-user] [options] names
	equota [options] -t


说明

修改用户或组配额，edquota是一个交互式命令，它会启动文本编辑器
(取决于EDITOR或VISUAL 环境变量，若没有，则默认使用vi)
让你编辑一个临时文件。当你保存文件并离开编辑器之后,edquota
会将临时文件存入用户或组的配额配置文件


此命令的第一种形式中，names是一连串以空格隔开的用户或组名称，代表
要被修改的
配额限制对象。如果使用-p选项，则复制proto-user(用户或组)
的配额配置到names(用户或组名单)，而不会启动编辑器


第二种形式(有-t选项) 让你以交互方式编辑各文件系统的软性限制


常用选项

edquota -g	
	变更组配额。names会被假设全为组名称，而非用户名称(即使同时指定
	-u选项也一样)

edquota -p proto-user

	以proto-user所代表的用户或组配额为原型，复制到names所列
	每位用户或组。此选项常用来同时初始化许多用户或组的配额


edquota -t
	变更软性限制。可使用sec(onds),min(utes),hour(s),
	week(s)以及month(s)等时间单位


edquota -u
	变更用户配额，这是默认行为。如果同时指定了-g选项，则本选项
	自动失效。


范例

1. 修改用户jdoe的配额限制

edquota -u jdoe

其中，jdoe在/dev/sda9上的软性限制wei 99900个块，硬性限制为100000个块，
没有数量(inode)的限制。它在/dev/hda1 上没有任何限制


2.修改用户于所有文件系统的软性限制

edquota -tu

用户的空间宽限期被设定为7天，文件数量宽限期被谁定为3天


requota


语法
	requota [options] filesystems
	requota -a [options]


说明


汇报配额状态。命令的第一种形式会汇报每位用户与组于特定filesystems的配额
限制总表，第二种形式则汇报所有文件系统的配额总表


只有root管理者可使用此命令，除非配额数据库被设成任何人都可以读取。
管理者常用此命令来查看edquota所建立的配额限制，以及个用户所耗用的
文件数与磁盘空间


常用选项

requota -a
	汇报/etc/fstab配置文件中所有可擦写的文件系统的配额状态。对于挂载
	选项中含有usrquota或grpquota选项中的文件系统，则汇报用户或组在
	该文件系统的配额限制

requota -g	
	汇报组的配额状态

requota -u
	汇报用户的配额状态(默认动作)
requota -v
	在输出信息第一行加上字段名称


范例


1.汇报/home的用户配额

requota -v /home


104.5 文件访问权限

任何号称用户(multiuser)的操作系统，都必须具备保证个人因素的机制，而“文件访问权限”
就是这个机制的具体实现。在Linux系统中，此机制不仅用于避免文件被他人窥视，同时也是
重要的系统保护措施，管理者借此避免重要文件(配置文件，程序，密码文件)遭受篡改


Linux的访问控制机制


"访问控制"的作用是要让适当身份的人获得适当的访问权。
所谓的“身份”就是文件对于用户的从属关系，而Linux/Unix系统所定义的三种关系如下：

owner(拥有者)
	文件的拥有者，通常就是产生文件的那个人

grouo(组)
	文件所属的组，很可能就是拥有者所属的组

other(其他人)
	既非拥有者，也不是组成员的其他人


访问权，是指用户对文件进行的操作类型。对于文件，Linux定义了是那种可能的操作。
"读"(read),"写"(write),"执行"(execute)

对于目录，同样也有三种可能的操作，列出所含的文件，增加新文件，进入该目录

操作权限


权限     符号         对于文件的意义            对于目录的意义
读取      r	    	查看文件的内容		列出目录内容
写入	 w  		写入(或变更)文件		创建、移除目录下的文件
执行	x		将文件当成程序来运行	切换(cd)到目录下

对于每个文件，文件系统的inode至少要记录其所属的"拥有者"
"组"以及9-bits的访问模式(access mode)
也就是拥有者，组，其他人这三种身份对文件各自具有那种访问权限

在ls -l的输出信息中，不会显示SUID,SGID,Sticky位的状态，只以
助记来显示访问模式位。。


SUID (Set User ID)
	SUID属性只对可执行文件才有意义，对目录无影响。原则上，当用户执行
	程序时，该程序所引发的进程皆属于启动该进程的用户。对于设立了SUID
	属性的可执行文件，无论是谁启动程序，该程序所引发的进程皆属于
	程序文件的拥有者，而非启动程序的的用户(除非刚好是同一个人)
	若程序文件拥有者为root，表示该程序的运行期间可临时获得root的
	权限，及时启动程序的人不是root.	
	SUID长应用于需要root权限才可运作，但是又必须工全体用户使用的
	程序，例如lpr.此程序的作用是让一般用户打印文本文件，但是它必须要有
	root特权，方能操作打印池(printspool)
	设计SUID属性的原始用意主要是为了避免泄露root密码，让一般用户可在
	不知道root密码的情况下，也可以使用需要特权才能运行的程序。
	然而，设定了SUID属性的程序往往也是系统安全的风险所在



SGID (Set Group ID)
	SGID对于可执行文件的效果类似于SUID,可执行文件所引发的进程
	可获得程序文件所属组的权限。此外，SGID属性对目录会有特殊效果
	对于一个设定了SGID属性的目录，当你在该目录下创建新文件时，
	新文件的所属组将会是该目录的所属组。
	例如，如果/home/fin/目录属于finance组而且设定了SGID属性
	那么如果在/home/fin/目录创建一个新文件，则该文件的所属组
	必定是finance,而非文件创建者的默认组。管理者常利用此
	属性来确保某目录下的所有共享文件都属于同一组


Sticky(粘滞)

	sticky属性只对可执行文件有效。其租用是让程序运行完成后，其镜像(image)
	仍留在内存里。此属性适合用于需要经常被重复运行的大型程序
	借此消除需要重复加载相同程序所造成的性能损耗。
	由于限制都可以虚拟内存技术，所以sticky属性其实已经没有用

	在目前的Linux系统上，sticky属性只对目录有效，对可执行文件无效(
	虽然此属性当初是针对可执行文件而设计的).对于一个设定了sticky属性的
	目录，该目录下的文件，文件的拥有者，目录的拥有者以及root都可
	改变文件名称或是删除文件，而且不受文件本身的访问模式的影响，
	管理者常用sticky属性让组成员可创建新文件，修改文件内容，	
	而只有文件拥有者才可删除文件或修改文件名

镜像(image) 是实际被CPU执行的程序代码
模式位

	文件或目录的模式位可用chmod工具来修改，但是使用chmod时，

每一个八进制数字各自代表一个意义
模式字符串
设定访问模式

默认访问模式
当用户创建新文件(或目录)时，系统会将"文件"(或目录)的初始模式"与"
用户当前的umask设定值进行逻辑运算，借此决定新文件(或目录)的访问模式

用于设定umask值的工具是umask

umask直接收一个自变量----一组三位数的八进制数字

umask 022

通常，系统的启动脚本会为全体用户默认一个合理的umask屏蔽值，
典型值包括002与022，讲究安全系统可能设定为077(这可阻断root之外的其他人
的访问)
如果想要改变自己的umask屏蔽值，可以在个人的启动脚本中安插适当的umask命令

umask命令除了可以设定屏蔽值，也可以查看现有的屏蔽值

umask

umask -S

umask以八进制数字来表示屏蔽值，-S选项表示以符号形式显示

变更访问模式

对于已存在的旧文件或目录，可用chmod命令来改变其访问模式
以符号表示法表示的模式可分成三段，分别代表"身份""操作""权限"

每一段各有自己的专用符号

u 拥有者(user)
g 组(group)
o 其他人(other)
a 全体(all)


- 取消
+ 新增
= 设定

r 读取(read)
w 写入(write)
x 执行(execute)
X 旧的访问模式中已有x权限时，才新增另一个x权限
s SUID 或SGID属性
t sticky 属性



u+x 让拥有者有执行权限
go-w  撤销组与其他人的写入权限
o+t 设定sticky属性
a=rw 让所有人都有读写权限
a+W 若目标文件(或目录)已有某个x权限，则赋予所有人执行权限

chmod 

语法

说明

chmod 主要用于调整既有文件或目录的访问模式。此命令的第一种形式
直接将目标文件的访问模式设定为octal_mode,覆盖
原有的访问模式；
第二种形式依据symbolic_mode来调整文件的访问模式；
第三种形式将file的访问模式设定给files,
files的访问模式


常用选项

chmod -c 如同verbose模式，但只会汇报变更的部分

chmod -R 递归模式。彻底调整整个子目录下的所有文件
	与子目录的访问模式

chmod -v 详细模式。汇报对每个文件所做的任何调整


范例

1. 以八进制表示法将afile文件访问模式

chmod 644 afile


2. chmod -v u=rw ,go=r afile

3. chmod -vR o-rwx scripts/

4. chmod -v +t adir


组织一个工作组目录

多用户操作系统中的需求：某一组人需要共享同一个工作目录，
自由访问该目录下得的所有文件，另一组人需要共享另一个
工作目录；各组成员只能访问自家的工作目录，而看不到其他组的工作目录

要如何组织工作目录？访问权限如何设计？首先，我们应该必须满足的条件列出来


1. 这个工作组称为sales,其成员有jdoe,bsmith与j


104.6  管理文件的拥有权

当你移动文件，成立工作组，组织目录或是以root特权代替其他用户操作原
属于他们的文件或目录时，会需要调整文件或目录的"拥有权"(ownership)
或它们的从属组。改变拥有权的命令是chown,而chgrp命令则可以改变所属组

chown -c 只汇报有变更的部分

chown -R  递归模式，影响整个子目录树

chown -v 汇报任何进行中的动作以及所做的改变


chgrp  


chgrp


注意
只有root可以变更文件的拥有权。chown具有chgrp的所有功能，不仅
能变更用户拥有权，也能修改组拥有权


104.7  链接文件的管理

为了方便访问，需要让同一个文件同时出现在多个位置。但，与其简历多个文件副本
比如利用"链接"(link)来达成目的。
"链接"并不会占据太多磁盘空间，因为它们只是在文件系统上增加了一些"元数据"
(metadata)而已，也就是可以用来找到原文件的索引信息

Linux有两种链接：“软链接”(soft link) 与"硬链接"(hard link)

软链接

软链接又称"符号链接"(sysbolic link),简写为"symlink"
这类链接其实只是另一个文件名的指针而已。
软链接本身也是文件，其内容是另一个文件的名称。
当linux开启软链接时，它会循指针找出含有实际数据的目标文件。
符号链接可以指向另一个文件系统(本机或远程都可以)，也可以指向目录。
在ls -l输出的文件列表中，

符号链接可以指向不存在的文件，这时的链接称为"断裂"(broken)或"失效"(stale)


硬链接

硬链接只是现有文件于另一个目录下的"入口"而已
硬链接与原文件只是以不同名称分居于不同目录下的"目录项"(directory entry)
它们指向同一个inode,具有相同的文件内容（磁盘上的同一块数据）
拥有前，访问权限，属性。当硬链接被删除时，原文件依然存在

原文件被删除时，硬链接依然存在。对于用户而言，除了文件名与目录路径不一样之外，
根本无法区别硬链接和原文件之间的差异


目录项：“目录”本身其实也是个文件，特别之处在于其内容是记录其他文件的
索引信息，这些索引信息就称为"目录项"

硬链接的限制：1.原文件与硬链接必须位于同一个文件系统。因为
它们必须指向同一个inode,而inode的编号是相对于文件系统的，
若跨越不同的文件系统，则无法保证不出现重复的inode编号
2. 硬链接不能指向目录，因为它们本身就已经是个“目录项”

硬链接的优点是几乎不占磁盘空间，因为它们只是其他目录的目录项而已。


为何使用链接？

以具体的应用实例来解释链接的用途

符号链接常备应用于维持旧的操作习惯。

ln 用于创建符号链接和硬链接的工具


ln -f 强制覆盖现有的链接或directory 下的现有文件

ln -i 覆盖目标文件之前先发出警告提示

ln -s  创建软链接。默认会创建硬链接

ln -i files。files必须包含完整路径或相对于directory的相对路径，否则
可能会产生自我链接。

ln -s ~/file* myproj/

范例


1. ln -s  /usr/src/linux-2.6.12  /usr/src/linux

2. 

touch myfile
ln -s myfile myslink
ln myfile myhinl

使用stat检查前述文件

stat my*

追寻链接

104.8 系统文件的位置

静态类型


文件系统是用来保存数据的，不同类型的数据应该分别放在文件系统上的不同位置。
共享性(数据与网络环境中的应用范围)

共享(sharable)
p223


