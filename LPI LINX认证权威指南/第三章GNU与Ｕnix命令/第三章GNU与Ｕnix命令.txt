

第三章GNU与Ｕnix命令(共８章)
８２
本章主要涵盖了linux命令行工具的基本使用技能

GUI　图形用户界面


103.1:命令行环境的基本概念

适应命令行操作环境，具备能与shell和命令交互的基本技能
输入有效的命令，定义，使用与导出环境变量，操作历程记录(history)
与编辑功能，设定命令搜索路径，启动在搜索路径之处的命令，
使命令递归地处理整个目录树等



103.2　使用过滤器处理字符串流

要能使用GNU texttutils包里的工具来处理字符串流


103.3 基本的文件管理技巧

能够使用基本的文件操作命令，对文件与目录进行复制，移动，移除等
操作。还包括高级的文件管理操作，像是递归赋值多重文件，移除整个子目录树，
运用通配符(widcard)来移动文件，使用find来寻找符合某特定条件的文件等

103.4 流，管道与重定向的运用


流(stream)是Unix/Linux操作系统上最关键的概念之一，借由shell的管道
(pipe)与重定向(redirect)机制将多个小程序的I/O串接在一起，
使它们共同完成原本由个别程序无法办到的处理效果。
要有使用管道与重定向来构筑流的能力


103.5 进程的创建，监控与撤销


进程(process)是Unix/Linux的虫咬内核概念之一，如何管理长期运行的进程
是Linux系统管理者的重要课题。能够改变工作(job)的前台/后台运作状态，
启动不连续终端机的进程，使进程储蓄保持运行而不因启动该进程的用户注销
而中断，监视活动中的进程，传送信号(signal)给特定进程，辨识进程的运行
状态，终止运行中的进程等


103.6 调整进程的优先级

Linux是一个多用户多任务操作系统，为了让多个进程得以同时运行，对于
系统上活动的每一个进程，内核都各赋予其一个称为"优先级"(priority)
的参考值，此值会影响调度程序(scheduler)分配给进程的CPU时间的多寡。
如何修改进程的优先级，使其获得较多或较少的CPU时间配额

103.7 以正则表达式搜索文本文件

正则表达式(regular expression)是一种描述文件样式的语言，许多涉及
文字处理的工具都内置了正则表达式引擎，让你用语法来描述想要处理的文字样式。
运用grep,sed等工具来搜索或修改文件内容即可


103.8 vi的基本编辑凑走


能够使用vi对文本文件进行一些简单的编辑操作。

103.1 命令行环境的基本概念


用户界面(UI)是每种计算机系统的必要组件。对于Linux系统管理，通常
选择文本类型的用户界面(TUI).文本用户界面会以一个"提示符号"(prompt)
让用户/管理者知道，系统已经准备好接受命令的下达。
在提示符号之后，用户可键入一行或多行的文字命令。


负责提供提示符号并解释命令意义的程序统称为shell(壳)。因为这类程序是
系统与用户之间的接口，对用户而言，shell提供的环境就像计算机系统的外壳。
linux系统默认的shell是GNU参考sh所写出来的版本，称为bash(Bource-Again Shell)

Unix/Linux系统的shell不单是能够与用户交互的操作环境，同时还是一个强大的
程序设计环境


Shell操作环境你


当用户成功登录系统后，登录程序会自动启动shell,出现一个提示符$,#
有时，也有一些额外信息，比如主机名称，用户身份，当前的工作目录等

此时，表示shell已经准备好从它的标准输入(stdin)---键盘，接受你的命令

shell可以独立运行，就像在实体终端机上，也可以在GUI环境的窗口中运行

shell变量


在bash的运作期间，它会维护一组"shell变量"，这类变量含有bash运作时所需的
重要信息。大多数变量是在bash刚启动时就设定好，但是用户可随时动手改变设定值，
借此改变shell的行为表现


shell变量称为PS1(Prompt String 1),其值是一个代表"命令提示符号"的字符串。
既然有PS1,也会有PS2.它是bash在接受多行输入时，从第二行开始显示的提示字符串，
使用echo命令可显示变量的内容，方法是在变量名成之前加上一个$符号

echo $PS1

在此例子中，PS1字符串只含两个字符:\,$
\本身是一个特殊的字符，其作用是要求bash改变其后字符的解释方式：
当接在\之后的是元字符(meta characher),则解释为普通字符；
若是普通字符，则解释为元字符。
在此例子中，$本身是一个元字符，所以\$的意义是一个$符号

u,h,w本身都是普通字符，由于加了\
变为\u,\h,\W，所以bash将它们解释为元字符，其意义依序分别是
用户名称(username),
主机名称(hostname)
当前工作目录的名称(working directory)

提示符号的形式不影响shell对输入命令的解释

另一个会影响与shell交互的重要变量是PATH,也就是搜索路径(search path),
PATH变量值由一系列以冒号(:)隔开的路径所组成，当bash在搜索你
输入的命令时，会逐一依序到PATH所列的目录下去寻找。
在Linux系统启动期间，启动脚本(startup script)会将　典型的程序目录
纳入PATH变量，让你不必输入完整路径名称就可以启动大多数命令，
如果你将程序安装在PATH中找不到的目录，可以修改启动脚本，
使其包含你的程序目录


要让bash能够顺利找到并执行你在提示符号值所键入的命令，该命令必须：
１．是一个bash内置命令(命令本身是bash的一部分)，或
2.是一个可执行程序，其存放目录已列在PATH变量中，或
３．有明确的定义(即标明了完整的路径名称)


$元字符的作用是要求bash将其后的字符串视为变量名称，这就是为何要在
PS1变量名称之前加上$，否则echo会直接显示出"PS1"字符串，
而不是PS1变量的内容

shell变量不仅供自己使用，还可以供shell所启动的程序(包含其他shell(subshell))
使用。为了让其他程序也能取用shell变量。
它们必须被导出(export)成为环境变量(environment variable)
对于bash,PATH是当然的环境变量。
用于导出shell变量的命令是export

export MYVAR


环境变量会出现在所有子进程的环境变量中。由shell启动的所有程序都能够取用
父进程导出的环境变量


单行命令

在Linux系统上，用户对shell所下达的命令通常由四个部分组成：

１．一个有效的“命令”(shell的内置命令，存放于PATH所列目录中的程序，脚本
或是一个含有完整路径的程序文件名)

2.改变命令默认行为的“选项”。选项前通常会有一个破折号(-)
3.描述命令处理对象的"自变量"
4.触发机制(即按下Enter键，)

ls会列出工作目录下的所有内文件，

ls -l 列出详细的格式列出文件。在默认情况下，ls不会列出隐藏文件与隐藏目录
(名称第一个字符为.的文件或目录)。除非指定了-a选项，

列出ls -a 列出隐藏的文件

当需要改变命令的默认作用对象时，便必须加入自变量(argument)----有时也称为
参数(parameter).同样以ls为例，

查看当前目录下有哪些.c文件


ls -l *.c


ls --all*.c -l


由于有破折号的关系，ls可认出一个选项，而非文件名，并非
所有命令都强制要求选项之前一定要有破折号，最著名的例子是tar与ps
在这种情况下，选项与自变量的顺序就很重要

tar cf my f1 f2
tar -cf my f1 f2

都是将f1,f2封装成一个my文件。其中,f选项用来让tar直到，紧随其后的自变量
my是封装文件的文件名

linux命令范围极广，大多数系统管理者都会持续探索，复习自己常用的命令，
以学习还不熟悉的功能
定期查阅相关命令的man或info文件，是大多数系统管理者的标准学习模式


运行不在PATH中的程序

程序会被放在PATH所列目录之外的其他位置。运行这类程序，一个办法就是
在命令行指出程序文件的完整路径，假设要运行放在/opt/bin/目录下的ls程序

/opt/bin/ls


可以将/opt/bion目录(或用来放程序文件的其他目录)加入PATH变量：

export PATH="/opt/bin:#PATH"


之后，就直接输入命令
ls即可



shell会遵循搜索PATH变量中所列的每个目录并运行第一个找到的ls程序。
由于系统在开机期间会重新设定PATH变量，若要将你的新搜索路径延续到往后的
每一次开机，就得修改启动脚本

除了shell之外，还有一些程序也会到PATH所列的目录去寻找程序文件。因此
及时可以顺利地启动一个程序，但却可能会因为PATH所列的目录不够齐全，使得该程序无法
找到所需要的资源而导致运行失败


注意，
当前Linux系统的PATH变量默认值通常不含"当前工作目录"，这表示不能将工作目录
切换到程序所在的目录，然后以不含路径的程序的程序文件名来运行程序

除非该目录就已经被纳入PATH,要运行当前工作目录下的程序，必须在程序文件名
之前加./   例如./a.sh

PATH不含当前工作目录主要是基于安全考虑，


多行命令

Ｕnix系统的shell不仅能与用于交互，还具备程序语言能力，可以直接在名林航输入
跨越多行的shell　script。

例如，
在命令行输入for,until,while之类的循环结构时，及时按下了 Enter键，
bash峰会不断历史

与其自己重复键入相同的命令，不如以交互的方式使用bash的for循环结构处理

for var in ar1 ar2 ar3
do
echo $var
...一串命令...
done


如上的方式结合command-line(命令行)与shell-scripting(shell程序设计)


键入一组命令


在单一命令行同时下达多个命令，应该执行顺序键入每个命令，并以分号(;)
命令分隔符(command separator)，来将它们隔开

ls ; ps

应考技巧，注意命令行的选项和自变量的用法

命令历程与编辑

单独编写一个shell脚本

与bash交互时，所下达的每个命令会先被shell记录在自己的"历程表"(history list)
然后才开始进行解读与执行。
在里程表中的命令是命令的原样，不是展开通配符(*.?)之后的结果

历程表的容量由shell变量HISTSIZE所控制，
默认值是５００行，也可以调整
当你注销系统时，也就是shell变量HISTFILE所指定的文件。

当你下次登录系统时，仍然可以调出前次登录期间所输入的命令


使用bash的内置命令history可调出历程表。
会看到每个命令之前都被加注了行号，
用hisory所显示的行号。所谓的"历程扩展"，就是重新
执行历程表所记录的旧命令或旧命令的变异版本

历程扩展的语法


!!  代表历程表ｉ的最后一个命令。"bang-bang"
!n  代表历程表里的第n个命令，n就是history命令所显示的编号
!- n　　代表历程表中的倒数第n个命令
!string 代表历程表中最后一个开头为string的命令
!? string  代表历程表中最后一个含有string字样的命令
^string1^string2  重复最后一个名，但将命令中第一个出现的string1替换为string2


注意，在linux系统中, 惊叹号(!)常念成"bang"

注意，
如果在窗口环境同时启动多个shell，只有最后结束的shell才会将其历程表写入

使用"历程扩展"语法或上下方向键,调出历程表中的命令后，可以用命令行编辑
功能将旧命令改成想要的形式。
~/.bash_history。请选定其中一个shell来几种处理大部分工作，而且
这个shell必须最后结束


被重新执行的命令会自动成为历程表的一部分，


在bash的命令行，可以编辑器，移动，寻找，剪切，粘贴，来编辑调出的命令。




组合键


C -p 将光标往上移动一行
C -n  将光标往下移动一行
C -b　将光标往后移动一个字符
C -f　将光标往前移动一个字符
C -a　将光标移到行首(Home键)
C -e 将光标移到行尾(End键)
C -l 清楚画面并将当前的命令行移动到画面顶端(clear)


bash　也支持vi风格的编辑操作


M-<  移动到命令历程的顶端
M-> 移动到命令历程的尾端
C-d 往右删除一个字符(所删除的是光标所在位置的字符)
C-k　删除(kill)自光标所在位置开始至行尾间所有的文字
C-y　粘贴(yank)先前所剪切的文字
M-d  删除(kill) 一个单词
C-r text 反向查找text字符串
C-s text 正向查找text字符串


命令替换

bash 有命令替换(command substitution)的功能
可以让你将子命令的执行结果作为完整命令的一部分，
在编写脚本(script)时


子命令有两种可能的格式

$(subcmd)
'subcmd'


其中的subcmd可为任何有效的shell命令。
当bash遇到上面格式的子命令时，会将它们替换成subcmd的执行结果


$RCSIZE=$(wc -l -/bashrc)


上面的例子中，子命令四wc -l ~/.bashrc这部分，它会算出.bashrc文件的行数。
假设执行结果是20，就相当于

$RCSIZE=20


PS1="'whoami'@'uname -n' \$"

这个例子有两个命令，其中whoami会显示出当前用户的登录账号，而uname -n会
显示处理主机的网络结点名称，若上述命令放在网络主机为superlinux的bash
的启动脚本中，当john登录该系统时，会看到如下命令行提示符号：

john@superlinux $

两种命令替换语法的主要差异在于："subcmd"对于元符号的一些特殊处理规则是
$(subcmd)所不允许的；
此外，$(subcmd)的cmd可包含另一个$(subcmd)，但是
“subcmd”不允许多层的命令替换


最红，无论哪种形式，subcmd本身都是在subshell的环境中执行的，
若subcmd改变了任何变量，它们的效力会跟着subshell的消失而消失


递归地处理整个目录树


需要对整个目录树(directory tree)进行同样的处理动作，让命令的作用
对象跨越当前工作目录，扩及到整个子目录树。

如何让linux命令进行递归处理：有两种方法：
１．利用命令本身提供的递归选项(通常为 -r或-R),许多GNU命令本身都提供了
递归选项，以改变文件访问模式的chmod名

chmod g+w *.c


上述命令让同组成员可以写入工作目录下的所有.c文件。
现在，若要让同样的访问权限扩及当前工作目录下的所有目录里的.c文件，
可以运用chmod本身的-R选项(--recursive)

chmod -R g+w *.c


上面的效果相当于逐一进入每一个子目录来执行chmod g+w *.c

必须要有足够的而权限。除了chmod之外，还有薛国栋命令具有递归处理能力

包括，
cp 复制文件
ls　列出文件
rm　删除文件

如果命令没有递归处理能力，就使用find没你老公

find具有递归搜索能力，而且能执行另一个名

find的组合命令，可以对任何目录树进行几乎任何命令操作。
先从find的搜索能力开始


比如要处理对象是src/子目录下的任何文件

find src/


若只想处理src/目录的.c文件，则可用-name选项来描述我们想找的文件名样式

find src/ -name '*.c'


找出要处理的对象后，可以利用find的-exec选项，针对搜索的结果执行指定的命令。

-exec选项后接一系列字符串，最后必须以\;结尾


find src/ -name '*.c' -exec chmod g+w {} \;


上面的例子，对于每一个所找到的文件，find会分别执行一次chmod g+w {}mingl 

{}是一个特殊变量，它代表find所找到的文件的路径。

例如，find找到三个文件，

./src/p1.c
./src/p2.c
./src/p3.c

find会分别执行一次下列三个命令


chmod g+w ../src/p1.c
chmod g+w ../src/p2.c
chmod g+w ../src/p3.c


find也允许使用其他条件来搜索文件，像是问价你的最后一次修改日期，保护模式，
类型(文件，目录或链接)等

递归执行赋予了单一交谈式命令强大的能力，让它可以跨越当前目录(current directory)

103.2 使用过滤器处理字符串流

linux系统上有很多统称为过滤器(filter)的工具，它们可以从自己的标准输入(stdin)
或其他文件送入字符串流(text stream)加以修正，最后送往标准输出(stdout)
或存入新文件。

可用管道(pipe)将不同功能的过滤器串接在一起，使他们通力达成单个
过滤器办不到的修整效果。


cut 

cut options [files]

说明

将输入行的特定字段"裁切"出来(显示出来)。在默认情况下，cut将tab视为
字段分隔字符，除非你以-d选项执行其他分隔字符。cut影响原始输入文件


常用选项


cut -d list
cut -c list
cut -d delim
cut -f list



cut -d list

	显示出位于list所指定位置的字节。list是一连串以逗号分隔的数字，
		位置是以byte为计算单位
	
cut -c list

	显示出位于list所指位置的字符。list是一连串以逗号分隔的数字，
	位置是以column(字段)为计算单位

cut -d delim

	定义字段分隔符为delim字符
cut -f list

	显示出list所列出的字段。list是一连串以逗号分隔的数字，代表字段你的编号


例子


1.显示/etc/passwd文件(以冒号作为分隔符)中的第一个字段(用户名称)

cut -d: -f1 /etc/passwd

2.显示/etc/passwd 文件每行的第一个字段


cut -c 1 /etc/passwd


expand 

	expand [options] files

说明
	将输入流中的tab字符转换成等宽的若干个space字符。虽然tab有助于
	排齐文本，但并非所有输出设备对于tab的解释都一样。所以，在某终端
	机(或编辑器)上在其他地方可能很乱，解决办法是将tab字符换成适当
	数量的space字符。
	在默认情况下，expand假设一个tab字符的定位效果相当于8个空格

常用选项


expand -t number
expand -i


expand -t number

	指定tab字符的等效空格宽度(默认值为８)

expand -i
	只转换出现在行首的tab字符


fmt 
	fmt [options] [files]

说明
	将文稿编排成指定的宽度。过长的行会被换到下一行(安插一个\n字符)，
	过短的行会被连接到前一行末尾(移除前一行末尾的\n字符)。
	如果同时指定多个文件，则将所有文件的内容都视为连续的字符串流


常用选项

fmt -u
fmt -w width


fmt -u
	使用一致的间隔方式：单字(词)之间隔１个空格，句子之间间隔2个空格

fmt -w width
	将版面宽度(每行的字数)设为width,默认为75


head 
	head [options] [files]


说明
	显示出文件开头的前几行，。若同时指定多个文件，于每个文件开头处内容
	之前会多显示一个标头，以便区分


head -c n
head -n m


head -c n
	显示出前n个字节的内容。若n后面附加了k或m,则计算单位将会相应变成
	千字节(KB)或兆字节(MB)

head -n m
	显示出头m行的内容，默认值为10



join

	join [options] file1 file2


说明

	依据所指定的字段将来自file1与file2的两个表格合并成一个表格


join -j1 nfield
	索引字段为file1的第nfield个字段

join -j2 nfield
	索引字段为file1的第nfield个字段
join -j field
	将file1与file2共同的field视为索引字段



范例

join -j 1 file1 file2


nl

	nl [options] [files]

说明

	为files里的每一行加上行号。nl主要是用于给"正文"编行号，
	所以它提供了特殊的页眉(header)与页脚(footer)选项，让你
	将这些原本不应该被编号的文本行排除在外。
	每个逻辑页面(logical page)的第一行的内容编号为1
	一个逻辑页眉是由页眉，内容，页脚三个部分组成，
	这三个部分依次序由特殊字符串 \:
	
常用选项


nl -b style
nl -f style
nl -h style
nl a
nl t
nl n


nl -b style
	设定内容的编号方式，默认方式为t(只有非空白才有编号)
nl -f style
	设定页脚的编号方式，默认方式为n(无编号)
nl -h style
	设定页眉的编号方式，默认方式为n(无编号)

各种编号方式如下：

nl a
	全部编号，包括空白行
	
nl t
	只编号非空白行
nl n
	完全不编号

pREGEXP  
	只有匹配REGEXP正则表达式的文本行才编号


范例


假设文件file1的内容如下

nl -h a file1

只有页眉与内容才有编号，而页脚没有。每隔一个逻辑页面就会重新编号

od
	od [options] [files]

说明
	以八进制(octal)数值格式显示文件内容。od主要用于显示binary文件
	的字节编码。除了八进制之外，也可以选择ASCII,十六进制等表示格式。


常用选项

od -t type
od -ta
od -tc
od -to
od -tx


od -t type
	选择字节的表示格式。各种type的意义如下
od -ta
	字符名称(例如，00表示nul)
od -tc
	ASCII或backslash escape(例如，00表示成\0,65表示成A)
od -to
	八进制数值(默认)

od -tx
	十六进制数值


文本中的内容
\n 是ASCII newline字符。以a格式显示此文件

od -t a file1

每行开头的那一长串八进制数值的数字代表该行数据在文件中的相对位置，其后才是
数据本身的表达方式。由于我们要求以"字符名称"来表示，所以\n被显示为nl(new line的缩写)

paste

	paste [options] files

说明
将一个或多个文件的内容横向排列在一起。每个输入文件的第一行都将称为
合并结果的第一行的独立字段


常用选项


paste -d "n"

paste -s



paste -d "n"
	以n为字段分隔字符(默认的分隔字符是tab)

paste -s
	将输入文件的内容纵向列在一起。有多个输入文件时，每个文件的内容自称一行



合并两个文件的内容，pastee所产生的输出(横向排列)为：

paste f1 f2

使用-s选项时，paste所产生的输出(纵向排列)为

paste -s f1 f2


使用-d选项将字段分隔字符从tab改为@


paste -d '@' f1 f2



pr
	pr [options] [file]

说明

将文本文件的内容转换成分页，分段的版本，并且另外加上页眉与页尾。
页眉可还有日期，时间，文件名以及页码的等信息。
pr主要用于在"原样打印机"(没有打印机语言的原始打印机)产生漂亮的
输出字符串流


常用

pr -d
pr -h header
pr -l lines
pr -o width


pr -d
	两倍间距
pr -h header
	以header替换页眉中的文件名

pr -l lines
	将页面的长度设为lines,默认为66行，最低为10行
	
pr -o width
	将页面左边留白宽度设定为width


sort

	sort [options] [files]

说明
读取输入内容，以字母顺序(或你指定的其他顺序)输出它们

常用选项
sort -f 
sort -n
sort -r
sort -kpos1[,pos2]
sort -t 
sep为区别键值的分隔字符(默认值为空格符)

sort -f 
	不区分大小写字母的差异
sort -n
	以数值顺序排列
sort -r
	以相反顺序排列。不指定-r选项时，默认以升序排列

sort -kpos1[,pos2]
	以位于pos1(到pos2)的键值为排序依据
sort -t　sep
	
sep为区别键值的分隔字符(默认值为空格符)



例子
１．显示系统进程，以常驻部分的大小(ps输出信息中的RSS字段)顺序列出它们


ps aux | sort -k 6 -n


split
	split [options] [infile] [outfile]

说明
split可将大文件分割成若干个小文件。它先读出infile的内容，每隔1000行
(或你指定的行数)就写入一个新文件。
新文件以outfileaa,outfileab,等顺序来命名


以往通过电子邮件发送大型文件时，常会用此命令将大文件分割成一组
小文件以便分开发送。因为一次发送整个大型的电子邮件信息被视为一种不友善的行为


常用选项

split -n 
	每隔n(默认值为1000)行就分成一个新文件


split -2 file1 splitout_


将会产生三个新文件:splitout_aa,splitout_ab与splitout_ac

tac

	tac [file]

说明

	颠倒输入行的顺序，刚好与cat命令的效果相反(所以取名为tac)

范例

tac file1


tail
	tail [options] [files]

说明
显示出一个或多个文件中的最后几行。同时指定多个文件时，于每个文件的内容
之前会先出现该文件的文件名以作区分


常用选项

tail -c n
tail -f
tail -n m


tail -c n
	显示出文件中最后n个字节的内容，若n后面附加了k或m,则计数单位将会相应
	变成千字节(KB)或兆字节(MB)
tail -f
	显示出文件尾端内容后不关闭输入文件，并且在输入文件的末端出现新呢荣
	时实时将它们显示出来。管理者常用此选项来持续观察日志文件的内容变化情况
tail -n m

	显示出最后m行的内容，默认值为１０


tr
	tr [options] [[string1 [string2]]


说明
将string1里的字符转译成string2里相应的字符。tr本身没有file自变量，其数据
来源固定为stdin,输出目标固定为stdout.
如果string1与string2是范围的形式(a-z或A-Z),那么这两个范围所涵盖的
字符树木必须相同

string1和string2都可以含有多种特殊字符


a-z 从a到z的所有字符
\\　代表\字符本身
\nnn　ASCII编码值为nnn(八进制表示法)　的字符
\x　各种控制字符
\a　响铃(bell)
\b 倒退(backspace)
\f 进纸(form feed)
\n 换行(new line)
\r 回车(carriage return)
\t 横跳格(tab)
\v 纵跳格(vertical tab)


[:class:] POSIX字符类组
[:alnum:]　字母数字(字母与数字)
[:alpha:]　字母
[:blank:]　空格(space或tab)
[:cntrl:] 控制字符
[:digit:]　数字
[:graph:]　可显示字符(不含space)
[:lower:] 小写字母
[:print:]　所有可显示字符(含space)
[:punct:] 标点符号
[:space:]　任何空格符
[:upper:]　大写字母
[:xdigit:]十六进制数字


常用选项


tr -c
tr -d
tr -s


tr -c
	以相反意义解释string1
tr -d
	丢弃出现于string1中的任何字符

tr -s
	若输入数据中连续出现string1所含的任一字符，则将连续字符挤压(squeeze)
	到只剩一个


范例


１．将f1中的所有小写字符转换成大写字符

cat f1 | tr a-z A-Z


或

tr a-z A-Z < f1


２．　消除f1中连续的字符a(只留下一个):
cat f1 | tr -s a


3. 移除f1中所有的字符a,b,c:

cat f1 | tr -d abc



unexpand
	unexpand [options] [files]


说明
将输入文件中的space字符转换成tab字符。默认情况下，它假设tab的位置
是相隔８个space字符


常用选项


unexpand -a
unexpand -t number


unexpand -a
	转换所有space,而非只有每行开头处的space.通常，unexpand不会动刀
	正规文字开始之后的空格

unexpand -t number
	指定tab空白宽度(默认为8)



uniq

	uniq [options] [input[output]]


说明

读入stdin,消除连续的相同文本行，然后写到stdout.由于uniq只处理相邻的文本
行，所以通常搭配sort一起使用(sort可使所有相同的文本行都聚集在一起)


常用选项

uniq -d
uniq -u


uniq -d
	只显示出有重复的文本行
uniq -u
	只显示出不重复的文本航


剔除重复的

uniq f1



因为uniq只处理相邻的重复行。要彻底消除输入文件中的所有重复行，
必须事先用sort将重复行整并在一起：

sort file | uniq

若想查出哪些行是重复的，可以使用-d选项

sort file | uniq -d



wc

	wc [options] [files]

说明
计算files文件内容的字符数(char),单词数(word)与行数(line).
同时指定多个文件时，则分别统计各个文件的字数并分行显示各文件的
数据，最后一行则显示各项累加值


常用选项

wc -c
wc -l
wc -w

wc -c
	只显示出字符数
wc -l	
	只显示出行数
wc -w
	只显示出单词数


例子

1.命令统计f1,f2,f3，这三个文件的字符数，行数，单词数以及三项数据的综合


wc f[123]


2.计算当前工作目录下有多少个文件

ls | wc -l

先用ls列出当前工作目录下的文件，然后利用wc计算行数的能力计算出文件数


xargs

	xargs [options] [other_cmd]  [initial_arguments]

说明
将来自stdin的数据逐一作为other_cmd的自变量，逐次执行新构成的命令，
直到耗尽stdin为止。如果要执行的新命令有固定的选项或参数，则可以在
initial_arguments予以指定。从stdion读入的参数会接在initial_arguments之后

xargs主要是用来解决命令行过长的问题
或需要从其他命令的执行结果得到所要执行命令的自变量


常用选项


xargs -n maxargs
xargs -p


xargs -n maxargs
	限制每次传给other_cmd的额外自变量的数量
xargs -p
	交互模式。执行新构成的other_cmd之前会提示用户进行确认



范例

1.要想用rm删除某个目录下的所有文件,rm *

如果文件太多，可能超过shell能接受的命令行长度限制。
ls | xargs rm


2. 要在不同位置的文件中找出含有特定字符串(例如,"gg")的文件。
用于匹配文件内容的工具是grep
但是所需的文件名自变量刚好是要寻找的对象。
对于这种情况，可用find列出搜索范围内的所有文件，
然后通过管道由xargs代为产生并执行grep命令来匹配字符串


find / -type f | xargs -n 1 grep gg




上面的例子，find从根目录(/)找出type(类型)为f(文件)的文件(排除目录，链接
socket等特殊文件)，每当xargs从自己的stdin(已被管道接到find的stdout)
得到一个文件名(因为-n 1的关系)时，
就构建并执行了一次grep gg　filename命令

１０３．３　基本的文件管理技巧


对于文件系统的基本操作与管理是Linux用户绝对必要的技能


文件系统的基本操作技术，包括关于文件系统的基本概念，通配符以及涉及文件系统的各种标准管理工具
文件系统

linux的"文件系统"相当于 windows的"分区类型"(partition type)

linux也有“目录树”(directory tree) 


几乎每种操作系统都是以"层次结构"(hieracrhy)来组织其需要保存的对象，以“树状结构”来组织对象。

树状结构的好处之一，是有限度地允许同名对象的存在(只要它们最近的上层结点不同即可)

以“层次结构”理念设计出来的文件系统允许不同文件可以具有相同名称，只要它们不再同一个目录下即可。

因为linux是一个多用户多任务操作系统，不能因为某个用户选择了某个文件名，就剥夺了其他用户也选择该文件名的权利



文件系统对象

存储于文件系统上的对象(文件，目录，socket,链接...)的相关信息(标识符，名称，类型，大小，于磁盘上的位置，拥有者，访问权限...)
是记录在"文件系统表"中。此表本身是文件系统的一部分，其具体的结构定义随文件系统的类型而已。

linux系统中常见的文件系统类型包括ext2,ext3,Reiser FS,XFS等。

不过，对于用户而言，不同文件系统类型之间的主要差异并非"文件系统表"，而在于它们所表现出来的访问效率，容错能力，存储空间利用率等

虽然linux支持多种文件系统类型，它们都同样能够存储POSIX(Linux所遵循的操作系统标准)所规定的对象并以树状结构呈现这些对象。

最常见的两种文件系统对象是"目录"与"文件"


目录与文件

"目录"(directory)是一种用来容纳其他对象的对象，"文件"(file)则是一种用来容纳数据对象。

各目录之间的从属关系就是一个树，位于树状结构顶端的目录称为根目录(root directory)，其作用是容纳目录树的第一层对象。

描述跟目录的符号是"/"，它同时也是对象名称之间的分隔符号。
以ls命令的程序文件/bin/ls为例，
这表示该命令的实质程序代码是放在跟目录下的bin目录下的ls文件里



Inode


文件系统上的每一个对象的识别信息都记录于一种称为inode的数据结构中。
inode所记录的对象信息包括对象类型，在磁盘上的位置，修改时间，访问权限等
对于inode的组织与管理方式，随文件系统的类型(ext2,ext3...)而定。
当你使用mkfs.fstype制作文件系统时，其实就是将inode结构写入磁盘分区。对于Linux系统上常见的ext2文件系统，mkfs.ext2会预先配置一定
数量的inode.Linux文件系统还允许多个对象共享同一个inode.
此概念就是一般的"链接"(linking)

管理文件与目录的命令行工具

linux提供了一组管理文件与目录的命令，可以让用户用来创建，读取，修改，复制，连接，移动，或删除对象

linux GUI环境也提供了管理文件与目录的工具。命令行工具才是linux系统的精髓，也是考试重点


cp 

 cp [options] file1 file2
 cp [options] files directory

说明

可以复制或覆盖到file2。file1与file2可以是任何有效的文件名称，可以是完整的的路径明后才能或相对与当前工具目录的文件名

第二种形式会将一个或多个files复制到directory下。同时指定两个以上的自变量时，cp会假设最后一个自变量是目的地，


常用选型

cp -f
cp -i
cp -p
cp -rR
cp -v


cp -f
	强制覆盖现有的目标文件

cp -i
	覆盖目标文件之前先提示用户进行确认。
	
cp -p
	保留文件的所有属性信息，包括拥有者，组，使用权限以及时间戳。若未指定此选项，则未指定此选项，则新文件的属性将一下法则来设定：以
当前时间为最后修改时间，以权限位为操作者默认的访问模式，以拥有者与组为用户本身与用户所属的组


cp -rR
	递归复制整个子目录树。此选项的大小写形式是等效的。指定此选项的情况下，如果file1是目录而非文件，则会产生一个file2目录，其内容是file1
子目录树的完整副本
cp -v
	在复制进行之前先显示文件名称

范例

1.将系统日志文件(/var/log/messages)复制到当前目录下(以.表示)：

cp /var/log/messages . 


2. 将整个src子目录树复制到另一个新的src2子目录树保留所有文件属性

cp -Rp src src2


3. 将当前目录下的file1.file2,file5，file6,file7文件复制到个人目录下：

cp file1 file2 file[567]


应考诀窍：

弄清楚cp如何解读自变量，以及该如何强制覆盖现有文件或是如何避免无意覆盖现有文件


mkdir [options] directions

说明

创建一个或多个directories.你必须拥有新目录的上层目录的写入权限。


常用选项

mkdir -m mode
mkdir -p


mkdir -m mode
	将direcories的权限模式设为mode
mkdir -p
	创建direcories时自动创建不存在的中间层目录


范例

1.创建一个名为personal的新目录并将其权限设定为全部只读

mkdir -m 444 personal

2. 于自己个人目录(以～表示)下创建一个三层子目录树：
mkdir -p ~/dir1/dir2/dir3


上面的例子，若dir1不存在，则会依序自动创建 ~/dir1,~-dir1/dir2,~/dir1/dir2/dir3三个目录

应考诀窍

记住bash允许使用~符号表示用户自己的个人目录


mv
语法
mv [options] source target

说明对文件或目录进行移动或重命名。如果target的位置与source位于相同的文件系统(磁盘分区)，移动操作并不会改变文件内容
原本的存储位置，而是改变source所属的上层目录(相当于改变source的名称)；
但如果target与source 位于不同的文件系统，则source的内容会被复制到新位置，然后才删除掉source

注意

文件与目录的重命名操作也会使用mv,重命名操作需要更新(同一个)目录的数据项


如果target文件或目录不存在，那么source便会被重命名为target。如果target是一个现有的文件，那么
她会被source所覆盖；如果target是一个现有的目录，那么source便会被移往该目录；假设source是一个或多个文件，而
target是一个目录，那么这些文件都会被移往该目录


常用选项


mv -f
mv -i


mv -f
	强制完成移动，如果target存在，则会抑制警告信息的显示
mv -i
	移动文件之前提示用户进行确认

应考诀窍

对同一个文件系统(单一的磁盘分区)而言，"重命名"与"移动"其实是一样的操作，所以没必要另备专供重命名用的rename命令

rm

语法
	rm [options] files


说明

从文件系统中删除一个或多个files.对于要被移除的我呢间，你必须对该文件所属的目录拥有
写入的权限。
不必对该文件本身拥有写入权限。


常用选项

rm -d
rm -f
rm -i
rm -r -R


rm -d
	即使不是空目录，也强制移除掉。用户必须具备特殊权限
rm -f
	强制移除设有写保护的文件，而且不提示任何警告信息
rm -i
	移除文件之前提示用户进行确认
rm -r -R
	如果file是一个目录则递归地移除整个子目录树


rmdir


语法
	rmdir [option] directions

说明
删除空的directions



常用

rmdir -p
	连同中间层目录也一并删除。此选项可用来移除子目录树。

应考诀窍

rmdir删除尚含有文件的目录，但是使用rm -R则可以将目录树本身与所含的文件一并清除


touch

语法
	touch [options] files

说明
变更files的访问时间，修改时间。程序员常用touch来改变文件的时间戳以制造文件内容曾被修改修改过的假象(其实文件内容没变)
而使得make重新编译被touch 的程序文件


常用选项


touch -a
	只将文件的内容"访问时间"设定为当前时间
touch -m
	只将文件的"修改时间"设定为当前时间

touch -t timestamp

	
	指定所要设定的时间戳



文件名通配符

操作命令行时常会遇到需要一次描述多个文件的情况。
比如说，linux系统上所有的shell都支持文件名通配符(filename wildcard)来表示一组文件的集合。

例如，/usr/src/*.c 代表/usr/src/目录下的所有名称结尾.c的文件

/tmp/??.tmp代表/tmp/目录下的名称类似ll.tmp,ab.tmp,x6.tmp的所有文件。


这种内涵通配符的文件，称为file globs,而使用通配符的行为则称为globbing


shell会找出符合条件的所有文件名，编译出完整的自变量列表，然后才传给工具程序。




通配符的应用实例


1.帮助查找文件。


ls -l *linux*

2.组织与管理

mkdir perl python

mv *.pl perl
mv *.py python


3.数据检索。

ls con*/*/inv*.txt



课题103.4 流、 管道与重定向的运用


一切皆为文件(everyting is a file)
除了我们平常熟悉的数据文件之外，磁盘驱动器，磁盘分区，磁带机，终端机，
串行端口，鼠标甚至是声卡都视为文件，几乎都可以在/dev目录下找到对应的节点----也就是所谓的"设备文件"(device file)或"特殊文件"(special file)

应用程序可以用操作一般文件的逻辑来操作设备文件，程序可以对设备文件进行开启，读，写，改变文件指标，关闭等操作，
而这些操作将触发驱动程序发挥对应的功能

以终端(terminal)为例，当程序读取终端机设备文件时，会得到用户所键入的字符；当程序将字符串写入终端机设备文件时，
将可使字符串出现在屏幕上。
虽然把终端机作为文件的想法，
linux提供了简单一致的使用方法与程序设计环境


标准I/O与默认文件描述符


"标准I/O" 是shell的一种能力，用于控制或引导基于文本的Linux工具的输入，输出以及错误信息。
每个shell启动一个程序时，会预先给该程序提供三个“文件描述符”(File Descriptor,FD).

唯一例外的硬件是网卡。应用程序并非通过/dev节点来访问网卡，而是通过Linux内核提供的软件队列来收发网络封包。


事实上，大多数网络应用陈旭也不是直接透过内核队列来访问网络，而是透过socket(这也是一种文件)


从程序设计的角度来看，FD是一种含有文件控制信息的数据结构，让程序用来作为某文件的句柄(handle),所以FD也称为file handle(文件句柄)
标准I\O 会产生下列三个代码：


标准输入(standard input)
	标准输入通常简称stdin或称为FD 0.stdin是一个文字输入流，默认情况下，它连接到键盘。
	当你对一个交互式的文字程序键入字符时，程序是从stdin收到所键入的字符。不过有许多程序的命令行自变量可接受一个或多个
	文件的文件名，在这种情况下，stdin会被忽略

标准输出(standard output)
	 标准呢输出通常称为stdout或FD 1.stdout是一个文字输出流，供程序用于输出平常的信息。
	在默认情况下，stdout是接到终端机屏幕(或仿真终端机的窗口)，让程序写到stdout的出现在屏幕上

标准错误信息输出(standard error)

	标准错误信息输出通常简称为stderr或FD 2.	也是一个文字输出流，
	而且也是接到终端机屏幕或仿真终端机的窗口,这表示程序送到stderr与stdout的信息都会出现在屏幕上

	提供stdout与stderr这两个不同的FD,不只是为了让程序可将正常信息和错误信息分开，重要的是可避免错误信息干扰
	了管道处理流程

	对程序而言，标准i/o文件句柄的用法其实与一般磁盘文件的句柄一样。
	区别是前者是由shell代为创建，而后者是由进程本身于运行时自行创建。



管道(pipe)
从程序的观点来看，读取键盘(stdin)的动作月读取文件没有区别。
写出信息到文件的动作其实无异于写出信息到屏幕(stdout)。可将一个程序的输出输出转接到另一个程序的输入，
而联系两个程序的机制便称为"管道"(pipe) 
在命令行中，代表管道的符号是 |

grep "01523" order* | less

上面两个命令，管道符号之前是一个grep搜索命令，之后是一个单薄的less分页查询工具管道将grep送到标准输出的信息转接到less
的标准输入。
我们可以分页查看当前工作目录下文件名开头为order的所有文件以及任何含有01523字样的文本行



由于stdin/stdout是shell预先为程序建立的，所以管道的作用也是要靠shell来完成，
程序本身无法介入。
在同一个命令行可以同时存在一个以上的管道，形成所谓的流水线(pipeline)或文本流(text stream)

是指文字会从一个命令流动到下一个命令


管道的应用相当多元化

grep "File does not exist" error_log | awk '{print $13}' | sort > uniq -c | sort -nr | less


先从grep从网站的错误信息日志文件(error_log)中找到含有"File does not exist"字样的记录，然后以awk显示出第13个
字段(找不到的文件名)，然后排序，计算重复次数(uniq -c),再依据重复次数进行降序排序，最后将汇整结果交给less来分页显示


I/O 重定向


shell 提供了两种I/O 重定向符号，分别为<与>


cmd < file 
cmd > file

< 将文件接到命令的标准输入
> 将命令的标准输出送到文件

这两个符号改变了命令的I/O方向，合称为重定向(redirection)操作
如同管道，I/O重定向也是shell的功能，
程序本身不会察觉它们的输出被转到其他地方或是输入被换成其他来源


把用less分而已查看结果，换成> file，就可以保存了


grep "File does not exist" error_log | awk '{print $13}' | sort 
|uniq -c | sort -nr > /tmp/hot_missedpages


>会覆盖，  >>是追加新内容

> >> 都只是改变了stdout的出处，stderr依然会指向屏幕

nptdate 会取得网络时间来校正自己的系统时间。

将stdout或stderr转入文件时，shell会事先创建或开启目标文件，
然后才执行你的命令。
如果将stdout与stderr都转入同一个文件，则会发生竞争现象(race condition)
将无法得到确切的文件内容，甚至无法得到完整的信息

如果要将stdout与stderr都送到同一个文件，

ntpdate pool.ntp.org > /tmp/msg 2 >&


先将ntpdate pool.ntp.org命令的stdout (FD 1)导入/tmp/msg
然后将FD2(stderr)导入FD1所指之处(已经指向/tmp/msg文件了)
使用m>&n 语法时次序很重要，它的意义是将m指向n所指之处


ntpdate pool.ntp.org 2&>1 > /tmp/msg

则stderr的信息依然会出现在屏幕上，因为bash是从左往右解释命令的，
先将stderr指向stdout所指之处(屏幕)，然后才将stdout指向/tmp/msg文件

当你使用I/O重定向来创建文件时，必须避免同一个文件及时输入文件又是输出文件

不要直接改名字，

正确的做法是将执行结果输出到另一个临时文件，然后再改名(移动)回来

grep "stuff" file1 > file2
mv file2 file1


shell为程序默认的stdin是键盘，而你可以用<将它改成其他来源，通常是已含有适当内容的文件

比如myreport.txt文件的内容邮递给jdean@example.com;

mail -s "Daily Report" jdean@example.com < myreport.txt

在不改变stdin的情况下，mail原本会在终端机(stdin)提示用户输入邮件内容，
但由于我们将stdin指向myreport.txt文件，
所以这次你无需输入任何信息,mail也不会出现任何提示


常用的标准i/o重定向用

bash 语法                   重定向功能
cmd > file  将stdout(FD 1) 传送至file
cmd 1> file  将stderr(FD 2) 传送至file
cmd 2> file  将 stdout与stderr同时传送至file  
cmd > file 2>&1  将stdout与stderr分别传送至不同的文件
cmd > file1 2> file2    改从file接收stdin
cmd < file   将stdout附加至file的末端
cmd >> file  将stderr附加至file的末尾
cmd 1>> file  将stdout与stderr同时附加至file的末端
cmd 2>> file  将cmd1 的stdout与stderr都导入cmd2的stdin
cmd >> file  2>&1 
cmd1 | cmd2
cmd1 2 >&1 | cmd2




使用tee命令

管道与i/o重定向可以改变命令的i/o流方向，却不能复制流。
在屏幕上看到命令的执行情况，但同时又想将执行结果存入文件以便时候重复查看，可以利用tee来赋值I/O流

tee

语法
	tee [options] files

说明

将读取字stdin输入流同时复制到stdout与所指定的文件，就像T型水管接头那样

tee -a
	将输出流附加到files文件尾之后，不覆盖原有呢哦荣能够

范例

管道命令是由cmd1,cmd2,cmd3串接而成，其执行结果最后会被存入file1

cmd1 | cmd2 | cmd3 > file1

除了错误信息之外，要正常的输出信息，因为它们不是被导入下一个命令就是被转入文件。

cmd1 | tee file_cmd1 | cmd2 | cmd3 > file1


课题103.5 :进程的创建，监控与撤销


系统管理这的两项主要基本职责是文件管理与进程管理。

进程管理(process management)的用意在于保持系统能够平稳运行。通常，进程启动后的环境准备，运作和终结都是以内核自动
控管，无需管理者的介入

有时，也需要终止或重启一些大消耗的系统资源进程。

可能要发送某些特殊信号(signal)给运作中的进程，促使其进行某种预期中的动作
比如，你的服务器上有一组不能停止运作的重要进程，而你修改了它的配置文件，这时候就可能需要
送出能使其重新加载配置文件的信号


进程(process) 是“运行中的程序”(running procedure)的计算单位
对内核而言，于系统上运行的每一个"程序"(program)  ----无论是命令(command),应用程序(application)还是脚本(script)
全都是“进程的组合”

当登录系统时，自动启动的bash shell本身也是进程。你在shell中所键入的每个命令都会触发一个或多个进程，某些进程甚至会衍生
出新进程，称为子进程(child process)

1.生命周期(lifetime)
	进程的整个执行期间称为"生命周期"(lifeme).用户于命令行触发的进程(例如，ls)
	它们的生命周期多半相当短暂。但是对于提供公共服务的服务器进程(例如Apache web server)
	它们的生命周期就相当长，甚至是在系统启动之后就开始，直到关机或管理这予以结束时为止。一般而言，有daemon或server称号的程序
	几乎都是声明周期相当长的进程。
	进程结束其生命周期的状态我们称之为die(死亡)，而能够促成死亡的工具就是kill.
	因为它通常也能够传送不会造成进程死亡的其他信号(signal)给进程

2.进程标识符(ProcessID ，简称PID)

	当进程被启动时都会被赋予一个整数，称为"进程标识符"。每个进程都有自己
	专属的PID,当管理者要传送信号给进程时，就是以PID来描述
	要处理的进程。

3. 用户标识符(User ID,简称UID)与组标识符(Group ID,简称GID)
	进程所获得的访问权限继承自启动该进程的用户以及所属的组。有些长期
	运行的服务器进程可允许用户指定其他的UID与GID,使其在权限较低
	(较为安全)的环境下运行

4.父进程 (parent process)与子进程(child process)

	在系统启动期间，内核所启动的第一个进程是init,其PID固定为1，它是
系统上所有其他进程的终极始祖。你所使用的shell其实是init的一个子进程，而用户
通过shell所启动的每一个进程都是shell的子进程(shell自己是它们的父进程)

5. 父进程标识符(Parent Process ID,简称 Parent PID或PPID)

子进程的父进程标识符。如果父进程已消失，子进程的PPID属性将会编程1，
也就是init的PID

6. 运行环境(enviroment 或context)
	内核会为每个进程准备一个工作区，进程可从此工作区获得环境的配置信息，
	也就是环境变量(environment variable).进程的运行环境承继自父进程，
	但在进程的运行过程中，包括进程刚启动时所执行的初始程序，环境可能会被
	改变

7.当前工作目录(current work directory)

若命令行参数中的文件名不是完整的路径(第一个字符不是/)，则以当前工作目录为相对起点。
通常，进程的当前工作目录是用户启动进程时所在的目录位置。

注意，shell的内置命令，比如alias,bg,cd,echo,jobs,test并不会启动成
子进程，因为它们原本就是shell进程的一部分，


注意，有时会用task(任务)来指称process(进程)，理由是Linux是一个多任务
(multitasking)操作系统。一般对于multiprocessing的定义，是指系统能
同时发挥多个CPU的能力，让不同进程(甚至是同一个进程)可在不同CPU上同时
运作。，只要使用正确的硬件以及具有multiprocessing能力的内核，
Linux也能提供multiprocessing的效果


进程的监控(ps,pstree,top)


一个正常启动的Linux系统随时都有数十个甚至上百个进程同时运行。
Linux提供了许多可以监控进程运行状态的工具


ps
	ps[options]

说明
依据options所描述的格式显示进程的状态信息

常用选项


ps -a
ps -f
ps -l
ps -u
ps -w
ps -x
ps -C cmd
ps -U usr



ps -a
	显示连接终端机的进程，包括其他用户所拥有的进程。默认情况下，	
	ps只显示当前用户所拥有的进程

ps -f
	"forest"(森林)模式，以从属关系(family tree)来安排进程信息的
	出现顺序。父进程会排列在前，其后是其子进程。
	例如,ps -f -C httpd可显示 Apache web server 的
	所有进程

ps -l
	以长格式(long format)输出，所显示的内容将包括PRIority(优先级)
	PPID(父进程标识符)以及其他信息
ps -u
	以用户格式(user format)输出，所显示的内容将包括username(用户名称)
	以及start time(进程的起始时间)
ps -w
	以宽格式(wide format)输出，若显示的项目过多而超过终端机屏幕边界
	时，则转到下一行(默认行为是直接截断，不显示超出边界的项目)
	通常搭配-f选项一起使用

ps -x
	显示没连接终端机的所有进程(通常是长期运行的服务器进程)
ps -C cmd
	显示命令名称cmd的所有进程

ps -U usr
	显示由usr所拥有的所有进程


范例


在不附加任何选项的情况下，ps只列出属于用户个人，连接终端机的进程：
ps

合并a,-u,-x三个选项，ps将以"用户格式"显示任何符合下列两个条件之一的所有
进程：属于其他用户或没连接终端机。此时，选项是否前置破折号不会影响
命令执行的结果

ps -aux/aux


ps的某些选项仍然需要前置破折号


查询特定命令的进程，使用-C选项。

只显示 Apache web server的所有进程

ps u -C httpd



pstree
	pstree [options] [pid|user]

说明
pstree命令的功能类似与ps -f的"forest"模式。此命令会以树状格式来呈现进程
之间的从属关系。
pstree可以看到父进程、子进程间的从属关系


若指定了PID,则pstree会将PID代表的进程当成树根(root),否则会以init
进程(PID1)为树根。若指定了用户名称，则pstree会列出该用户所拥有的
所有进程。显示进程树时，pstree会使用类似线条的字符来描绘树的结构：
|代表直线，以+代表树的节点(若选用VT100的划线字符，则大部分终端机
将会以实线而非虚线来显示进程树)

在默认情况下，pstree会把同名进程分支合并起来，但是在合并之处加注被省略
的进程数

使用-c选项可关闭pstree的合并功能


常用选项

pstree -a
pstree -c
pstree -G
pstree -h
pstree -n
pstree -p



pstree -a
	显示进程启动时所使用的命令行自变量
pstree -c
	停止对同名的子树(或分支)进行合并
pstree -G
	显示进程树时以VT100的画线字符取代一般的字符。这么做将会有较好
	显示结果，但对打印或分页程序而言则可能造成反效果
pstree -h
	加强当前进程(通常是shell)从属关系的显示亮度。终端机本身必须具备
	加强亮度的功能

pstree -n
	对具有相同根源的进程而言，默认会以英文字母的顺序进行排序。此选项
	会让pstree改以PID值的大小来进行排序
pstree -p
	同时显示进程的PID


范例

１．显示进程树并标注各进程的PID

pstree -p



top
	top [command-line options]


说明

top 能提供类似ps的输出，不同的是top会持续更新画面，而不是
显示一次之后就立刻结束。当你需要监控一个或多个进程的状态，或想
了解各进程耗用了多少系统资源时，可以使用top


在top所显示的画面中，顶排是各字段的名称，比如开机时间，系统负载，
CPU状态以及内存使用量等。在默认情况下，top依据CPU使用状态
来动态调整进程的高低顺序，正在被CPU运行的进程会被推到最顶端。

可以用TERM环境变量让top来发挥终端机的显示特性，但如果没设定此环境变量
或是top不认识TERM所代表的终端机类型，top可能无法执行


常用的命令行选型

top选项不定要前置破折号


top -b
top -d delay
top  -i
top  -n num



top -b
	以批量模式运行。在此模式下，top只输出一次信息，然后就立刻结束，
	让你可将输出信息送往其他程序或存入文件。通常-b选项会搭配-n
	来指定状态取样次数。当使用了top所不支持的终端机类型是，
	也可以使用此模式
top -d delay
	将状态取样时间的间隔设定为delay秒，也就是每隔delay秒就更新一次画面。
	默认值为５

top  -i
	略过闲置(idle)，只列出活动中的进程
top  -n num
	设定状态取样次数。最后一次全用之后top会自动结束
	持续取样并不断更新画面，没有任何延迟。当你以root身份来执行top时，
	top自己可能获得最优先的执行权，而由于选项会使得top持续保持在
	高能活动状态，所以它会抢占CPU的所有闲置时间。
	以root身份执行top,此选项可避免在无意中触发了可让你后悔的命令

常用的交互模式命令


ctrl + l
h
k
n
r
s



ctrl + l
	重绘一次画面
h
	显示辅助画面
k
	kill(杀)掉进程。top将会提示用户提示进程的PID,然后传送信号
	给它(默认的信号为15,即SIGTERM)

n
	改变进程的显示数量。top会提示你键入一个整数值。默认为０，代表
	不限制显示数量，直到填满画面为止
q 
	结束top的执行
r
	renice进程(改变其优先级)。top将会提示用户键入进程的PID以及
	它的nice(谦和度)值，大于０的nice值将会降低进程的优先级，而小于
	０的nice值则可提升进程的优先级，但只有超级用户能够改变进程的
	nice程度。此命令在安全模式下会被禁用。
	
s

	改变画面更新的延迟时间，单位为秒。top将会提示用户键入延迟时间值，
	可使用带小数点的秒数


范例

１．让top每隔５秒自动更新一次状态信息(不给任何选项时的默认操作模式)

top

2. 将画面的更新周期缩短为１秒(使用-d选项)
top -d 1

3. 显示活动中的进程状态，不延迟持续取样,持续更新状态画面(可使用-d 0或-q选项)


top -qi

4. 将top的取样结果存入文件

top bin 5 d 1 > file1

此例子中的bin5是-b(批量),-i(略过限制的进程),-n 5 (取样５次)的综合，
而d 1设定取样间隔为1秒


应考诀窍，

Linux系统的父，子进程从属关系是重点，如何从各种进程监控工具的输出画面中辨识，
记住init进程的PID固定为１，而它是系统上所有进程的始祖

信号(signal)

系统上的每个进程随时都可以接收内核或用户发送来的信号(signal).这些信息号的
传递管道简称为进程间通信(interprocess communication,简称IPC)
信号本身不是字符串，也不是类似命令的结构，它们只是系统预先定义的整数值，
而且这组定义是所有进程的共识。
当进程收到信号后便会(或是被迫)采取特定行动。
例如，如果你在命令行启动的陈旭似乎"死"掉了，可能会选择ctrl +c 


事实上，ctrl+c　这个动作其实是促使shell帮你送出一个INT信号给正在占据
终端机的进程。Linux系统定义了大约60余种信号。每种信号都具备两个属性：名称与数值。

进程实际收到的是数值，名称只是方便查看而已
有许多信号是专供内核使用的，只有一部分信号可供一般用户使用

用户常用的信号

p135

信号名称　　　数值　　　　　意义与应用

HUP        1    挂断(hang up).当你注销系统或中断调制解调器连接是时，系统会	
		自动发送此信号所有活动中的进程。许多服务器进程收到此信号后，	
		会重新读取自己的配置文件。因此，管理者常在修改了配置文件
		之后主动送出此信号给对应的服务器进程，使新配置生效


INT　　　２　　　　　中断或停止运行。当键入 ctrl + c时，shell便会发送此信号到当前
	　　　　　　占据终端机的进程		

KILL　　　　９　　　立刻无条件结束运行。发出kill信号是一种非常手段，任何进程
			都无法忽略此信号
TERM　　　　15     温和地(如果可能)　终结进程。此信号用来要求进程以无伤害的方式
		逐步结束运行

TSTP　　　　２０　　暂停运行，待命恢复。当键入 ctrl + z时，进程收到的就是此信号


CONT　　　　１８　　恢复运行。此信号用来通知被TSTP或STOP暂停的进程，使得它们恢复
			运行。在你用ctrl + z暂停一个进程之后，若下达了fg或
			bg命令，shell所送出的就是cont信号


linux系统上应该有两个kill命令，一个是shell的内置命令，另一个独立存在的二进制命令


kill

语法
	kill [-s sigspec | -sigspec] [pids]
	kill -l [signum]

说明

第一种形式中的sipspec自变量代表你想发出的信号，它可以是以数字形式的信号值，也可以是
文字形式的信号名称，而且完整名称(例如sighub)或简名(例如hup)皆可


习惯上，信号名称都是以大写表示，但是kill也接受小写形式(不建议) 。没有指定sigspec
默认发送的信号是sigterm.pids自变量是接收信号的进程。


第二种形式的作用是列出有效的信号名称。如果指定了signum(一个整数)，则值显示
该数字对应的信号名称

范例一：

列出所有信号的名称与数值

kill -l

2. 传送sigterm信号给pid1000 与1001两个进程(以下全是等效命令)：

kill 1000 1001
kill -l5 1000 1001
kill -SIGTERM 1000 1001
kill -sigterm 1000 1001
kill -TERM 1000 1001
kill -s 15 1000 1001
kill -s SIGTERM 1000 1001



kill信号可能造成数据遗失的后遗症，所以应视为作不得已的手段


有superdaemon之称的inetd会在收到HUP信号之后重新读取自己的配置文件
如果你变更该配置文件，而且想让inetd重新设定自己，请发送HUP信号给它

kill -HUP 'cat /var/run/inetd.pid'


应考诀窍，kill可用于发送任何信号，而非只能用来终止进程。
指定进程与PID时，其在kill命令语法上的差异，由于
这两者都是整数，

终止进程

用ps或top的进程检测工具进行调查。
僵尸(zombie)进程　　

注意

在ps或top的输出信息中可看到zombie(僵尸)的存在。这类进程事实上已经
进入结束程序了，只不过因某些原因而停滞下列，导致"结束程序"本身无法结束。


如果你的系统中有层出不穷的zombie(僵尸)问题，这代表你的系统软件或应用程序可能有bug(缺陷)

当你终结掉一个进程时，附属的所有子进程也会跟着消失。
加入你终结掉的是一个shell。
那么，任何从shell启动的进程(包括所有subshell在内)也会跟着终结掉



shell的工作控制

linux是一种多用户多任务的操作系统，shell对于"多任务"特性的具体呈现在于它
的作用控制(job control)机制。作业(job)是shell虚拟出来的概念，你的命令
行下达的一个完整命令，无论该命令由几个工具构成，shell会将其视为一个"作业"
.shell环境下的一个"任务"就像图形环境中的一个"窗口"

在窗口环境下，可以同时开启好几个窗口，但只有一个窗口会接受你的操作(称作"活动窗口"
或"前台窗口")，其余窗口在后台运行(称为"后台窗口")
shell也可以让你启动多个作业，但是只有其中一个可占据控制台(console)
称为"前台作业"(foreground job),其余不占控制台的则是"后台作业"(background job)

由于后台作业没有控制台的使用权，所以无法从键盘获得用户的输入，无法输出信息到屏幕，用户
除了发送信号(signal)给它们之外，无法提供输入数据给它们。对于每一个后台作业，
shell会自动赋予一个"作业编号"(由１起算，循序渐进)


后台作业不占据控制台的特性，主要是为了让用户可以运行需要长期运行的程序，而同时又保持终端机(或
终端机窗口)的可用性。
网站管理员经常需要运行网站日志分析程序，这类程序可将分析结果存储于文件而不需要用户
交互操作，但是它们的运行时间相当长。在这种情况下，管理员可将分析工作放在后台，
空出控制台来编辑网页或进行其他操作

"作业"(job)与"进程"(process)并不一致。一个"作业"往往涉及许多独立进程，
这些进程唯一的共同点是:它们都是shell的子进程，
收到同一个shell的控制(这就是shell能够提供I/O重定向，管道这种穿针引线功能的原因)




启动后台作业的方法是在整个命令的最后端加上一个 & 符号


firefox &

上面的命令可以启动Firefox浏览器，shell会显示出作业编号(在方括号内)与PID,
随即让Firefox与控制台脱钩(unhook),让用户可以继续用控制台。
如果忘了附加&符号，你会发现shell不会显示提示符号，
而你自然也不能下达后续命令。此时，可以键入ctrl +z让程序暂停


然后执行bg命令将被暂停的程序放在后台，重启　bg

　　　　　




bg

语法
	bg[jobspec]

说明
此命令指定的作业(jobspec)放到后台运行，就如同启动程序附加了&符号，
如果指定的jobspec不存在或是没指定任何作业，则shell会假定你是指当前的
作业，也就是jobs所列的作业列表中标示了加号(+)的那个作业
被放在后台的作业会继续运作，不会停顿，除非运行到需要用户输入的阶段

fg
语法
	fg[jobspec]
说明


将控制台的使用权还给指定的作业(jobspec)，也就是所谓的"拉回前台"
使其能与用户交互。如果jobspec不存在或是没指定任何作业，则shell嘉定
你是当前作业(current job)


jobs

语法
jobs [options][jobspecs]

说明

列出shell当前所担负的所有未完成作业或是jobspecs所指定的作业


jobs -l
	连同PID一起显示

熟练掌握如何将前台作业放到后台，将后台作业拉回前台以及如何在作业之间切换


课题103.6 调整进程的优先级


多任务系统中每个进程所耗的资源不太一样，有些需要较多的CPU时间，有些
时常在等待硬件的I/O数据，而有些工作会耗费较多的内存。为了让所有进程都获得
合理的资源，Linux内核会评估各进程的状态，而主要的评估依据便是"优先级"(priority)
通常，管理员无需担心优先级的问题，因为内核会自动品股并动态调整。
原则上，对于短期进程，它们的优先级在整个声明周期中都是固定的。当进程的运行时间
超过一定限度或运行状态符合内核预先设定的一些条件(比如，等候i/o数据)
则内科会动态调整(调高或调低)它们的优先级。
除了放手让内核自动调整之外，Linux也允许管理员左右进程的优先级，促使特定进程
获得较多资源或是强制拉下特定进程



进程的优先级，即top或ps -l所显示的PRI字段。PRI是一个相对值，
数值越高，获得CPU使用权的机会就越大，占用CPU的时间也就越长。
另一方面，在一个负载沉重的系统中，低优先级的进程可能连运行的机会都没有


谦和度


当内核调整进程的优先级会参考到一个称为"谦和度"(nice number)的参数，
此参数使用用户以nice命令提供的


"谦和度"代表进程在系统上的合群程度，数值越高，代表越能够将CPU时间让出来

谦和度越高，优先级被往低修改的幅度也就越大，相反，谦和度越低，优先级
被往高修改的幅度也就越大。

谦和度的有效数值范围从-20到+19
负值(低谦和度)会提高优先级，正值（高谦和度）可降低优先级


对于用户启动的进程，初始谦和度默认是０，也就是不影响内核的优先级调整策略。
任何用户皆可在启动进程时指定正的谦和度值，但只有管理员(root)可指定负的谦和度。


nice
语法

nice [-n adjustment] [command]
nice [-adjustment] [command]


说明
调整指定进程的谦和度。对一般用户而言，adjustment是有效范围从1到１９的整数。
只有root才有权使用-20到１９的任何整数。如果没有明确指定adjustment,则默认为１０
command可以是任何有效的shell命令，不管它是否包含选项，自变量，I/O重定向
以及&后台符号，nice都能正确处理

如果adjustment与command都没有指定，则nice会显示当前的谦和度默认值(通常是０)


范例

如果你是管理员(root),有权以较高的优先级(负的谦和度)来启动程序。


注意负值的表示法：在第一道命令中出现了两个破折号(--10),第一个破折号
是选项的前置符号，第二个则是负号


当用nice命令调整交互式程序(文本编辑器，浏览器等)的谦和度时
如果是正值，可能会让终端机的反映很慢，谦和度越高，优先级就越低。
当其他进程开始忙起来，终端机就会被放在一边


改变运行中进程的谦和度

nice命令只能在程序启动时调整新进程的谦和度，对于已经在运行中的进程，必须改用
renice命令才能修改其谦和度

renice
	renice [+|-] nicenumber [option] targets

说明

将target所代表的进程(或进程组)的谦和度改成nicenumber所代表的值。

renice默认会假定targets是数值形式的PID，除非以特殊的option来改变targets的解释方式


常用选项


renice -u
	将targets解释或用户名称，让该用户所拥有的全部进程都受到影响
renice -p
	将targets解释成PID(默认行为)

范例

将PID501优先级降低到最低(谦和度拉到最高)

renice 20 501

调高用户jdean的所有进程以及PID 501进程的优先级

renice -10 -u jdean -p 501

此例子中的-10代表谦和度为负10，不必前置破折号(-)


注意，
谦和度的有效范围(-20到１９)以及谦和度与优先级两者的反比关系。
注意nice,renice的差异，以及在描述负谦和值时的语法差异


renice命令对进程组的管理很有帮助，特别是向调整的进程都是属于特定用户时
除了nice与renice之外，top的单键命令r 也可以改变进程的谦和度(可立即反映在NI字段上)


在unix系统中，允许相关的进程组成一个组，称为"进程组"(process group)
以ps aux | head -S 命令为例，此命令由两个进程组成，这两个进程构成一个"进程组"


课题103.7 :以正则表达式搜索文本文件

linux系统管理员经常需要进行大量的，重复性质的文字搜索或编辑。
网站管理员需要分析日志文件来找出最热门的网页或分析客源来源；
邮件系统管理员可能会被要求找出某人于某天的通信记录或分析垃圾邮件来源。

Linux提供了许多的工具(sed,awk,grep,perl语言等)
帮助管理员进行诸如此类的分析搜索工作，而这些工具几乎都有一个
共同的特性，就是就是"正则表达式"(regular expression)  regex,regexp


正则表达式一种模式匹配语言(pattern-matching language)
可以用一组语法来描述文本的模式(pattern)
模式，就是想要搜索的文本的共同特征。类似通配符(file glob)

模式(pattern)　大致由两种字符所组成：

元字符(metachacter)
	如同文件通配符?,*,元字符有字面外的其他含义
	^ 代表文段的开头处
	$　代表文段的结尾处
	
直接量字符(literal)
	代表它们自己，以其字面意义解释的字符



构思模式就是使用"元字符"与"直接量字符"来描述输入文件的三项基本概念：
"锚点"字符类""修饰符"



锚点(anchor)

	文段中的特殊位置。像是文段的开头处，行尾或段尾，字词边缘



锚点



符号　　　　　　　　　　　　　意义　　　　　　　　　适用工具
^     行首只有出现在模式的左侧左侧时才当此解释　　　全部
$　　　行尾只有出现在模式的右侧时才当此解释　　　　　全部
\<　　　字词左边在空白或标点之后，字母狮子之左的交界处　egrep
\>   字词右边在字母数字之后，空白或标点之左的交界处　　　egrep


字符类(character class)

	具有共同属性的一组字符的其之一。例如，数字，小写字母，
	可显示的标点符号或编码值在某段范围内的任一字符


字符类

类　　　　意义　　　　　　　　　　　　             　　使用工具
[...] 一个于列举范围内的字符(例如[abc],[A-Z])       awk,sed,egrep
[^...] 一个不在列举范围内的字符(例如[^abc],[^A-Z]) 　awk,sed,egrep
.   除了\n之外的任何单一字符　　　　　　　　　　　　　　　　awk,sed,egrep
\w   ASCII字符，相当于[a-zA-Z0-9]            egrep,sed
\W   非ASCII字符，相当于[^a-zA-Z0-9_]   egrep, sed


修饰符(modifier)

	修饰符必须与字符类结合在一起，用以描述字符类的数量(称为"量词"(quarity
modilier))　或是增加额外选择


修饰符


基础语法(grep)　　扩充语法(egrep)   说明
*               *             出现0次或多次　
\+　　　　　　　+　　　　　　　　　出现１次或多次
\?　　　　　　　　　　?         出现0次或１次
\{n,m\}　　　　　\{n,m\}        出现次数介于n到m之间
\|             |             可选项(alternation).左侧模式或右侧模式的其中之一
\(regex\)　　　(regex)      归组(grouping)并存储到临时变量(\1,\2...\9)


grep 的应用

grep 大概是Unix/Linux系统上

g/regular expression/p



上述编辑命令的作用格式将整篇文稿(global)中匹配regular expression
模式的部分显示出来(print)


grep 
语法
	grep [options] regexp [files]

说明
搜索files或stdin(如果没有指定files时)，显示出匹配regexp的行。
如果公式指定了多个文件，则每行之前会先显示所属文件的文件名


常用选项


grep -c
grep -h
grep -i
grep -n
grep -o
grep -v
grep -E


grep -c
	只显示匹配模式行的数目，而非匹配模式行本身
grep -h
	同时搜索多个文件时只显示匹配模式行本身，而不加注所属文件
grep -i
	忽略大小写字母的差异。模式abc的匹配模式行可以是abc,aBc,Abc,ABC等
grep -n
	加注匹配模式行于原文件中的行号。若有多个输入文件时，则文件名与
	行号都会被显示出来
grep -o
	只显示匹配模式的字符串，而不是含有该字符串的整个行
grep -v
	显示出不匹配模式的行

grep -E

	以扩展语法来解释regexp.这相当于让grep模拟egrep


范例


使用直接量字符组成，不含任何元字符。

２．grep "Aug 22" /var/log/maillog > /tmp/aug22.log


grep -o "to=<.*oreilly\.com\." /tmp/aug22.log > /tmpe/aug22.oreilly


grep -o，只显示出匹配模式的字符串，而非含有该字符串的的整行


cat  /tmp/aug22.oreilly | sort | uniq -c | sort -r

将整个分析过程写成一个管道命令：

grep "Aug 22" /var/log/maillog | grep -o "to=<.*@oerilly\.com\.tw"
\ >| sort | uniq -c | sort -r


grep 'file.*' file.*


sed 流编辑器


sed(stream Editor)是常用的过滤工具，可读入来自stdin或输入文件的字符
串流，依据给的命令或脚本来改变内容，最后将编辑结果送到stdout

sed 所执行的脚本可以只包含一个命令，也可以包含一连串复杂的编辑命令


sed

语法

	sed [options] 'command1 ' [files]
	sed [options] -e 'command1' [-e 'command2'...] [files]
	sed [options] -f script [files]



常用选型


sed -e cmd
sed -f file
sed -g


sed -e cmd
	代表其后的自变量是一道命令。指定多重命令时，每个命令之前都必须
	以本选项指出
sed -f file
	代表其后的自变量是一个脚本
sed -g
	替换操作的影响范围为"全局"(global)



sed 把字符串流的编辑过程分成"寻址"(addressing)与"编辑"两个阶段：
”寻址“是找出要被处理的文段的位置，而"编辑"是将输入文段修改成符合要求的
样子。sed的处理单位是"行"(line),也就是以\n(newline)字符隔开的字符串。
如果公式有多个编辑命令时(多个-e选项或以-f script选项脚本)
则会在所有命令都作用在一行文字之后才会继续进行下一行文字的处理。
sed不会影响其输入来源(无论是stdin或文件)，只能从它的stdout
得到编辑后的结果

寻址


sed中的"地址"(address)是用来表示编辑命令所要作用的行的位置。
地址的可能形式包括：


1.一个以斜线符号界定的正则表达式(/regex/).
２．行号(注意，跨越不同的输入文件时行号不会归零).第一行的编号为１，
$符号代表最后一行，(start,end)代表一段范围

3.有间隔的行号，表达形式为n~s,其中的n代表起始行的编号，s代表
间隔数。例如,1~2(从第一行开始，每隔两行)代表所有奇数行。
只有GNU版的sed才有扩充功能


若在地址前加上!符号，表示将它们排除在外，若不给定明确地址，
则宝石编辑命令会作用在所有输入行


编辑命令

sed的编辑命令是放在地址(如果有)之前，编辑命令通常只是一个字母而已，
除非它们需要额外参数

sed d
sed s
sed g
sed n
sed p
sed w file
sed y

sed d
	删除整行文本
sed s
	替换。s/pattern/replacement [flags]

可用的flags(标记)
g 全局替换。全文中任何与pattern相匹配的每个文段被替换成replacement,	
	而不是只有第一个相匹配者
n  替换第n个与pattern相匹配的文段。默认值为1
p　显示出被成功替换的行。此标记通常会与-n命令选项并用
w file 将完成替换的文本行输出到file文件
y  执行类似与tr命令的转换程序



范例

1.删除file1文件的第三行到第五行

sed '3,5d' file1



2. 删除file1 文件中所有以井字号(#)为首的行：

sed '/^#/d' file


3. 将字母a换成字母x,b换成y,c换成z


y /abc/xyz/


4.将file1里的所有空白行(只含一个\n字符的行)替换成@符号


sed 's/^$/@/' file1


5. 移除file1文件中的所有双引号：

sed 's/"//g' file1


6. 让sed执行外部文件sedcmds里的编辑命令来处理file1

sed -f sedcmds file1


假设我们只想编辑file1的前十行(从第十一行以后的内容不受影响)
,将每行的第三与第五个双引号分别替换成"(" 与")"

1,10{
s/"/(/3
s/"/)/4
}

两个s(替换)命令的"位置标记"。sed脚本中的每个命令，它们的位置
编号是单独计算的，而由于编辑命令是依序执行，所以下一个命令所收到的输入
流是前一个命令处理后的结果。


在编写sed脚本时，不要照着原始输入内容来编写每道命令，而应该先
设想前一个命令会产生怎样的处理结果，然后一次构思新命令

当你需要定期对许多文件进行同样的编辑处理时(比方说，将日志文件改成
适合分析的格式)，就很适合将你的例行性编辑程序写成sed脚本


以正则表达式来描述地址


sed命令中"地址"　也可以用正则表达式来表示。

sed [options] 'command' [files]

范例

1.删除空白行

/^$/d


2.删除不含"#keepme"字样的行

/#keepme/|d

3. 删除全由空格符(tab或space)构成的行：

/^[ \t]*$/d

对于支持POSIX字符类的GNU　sed，
/[[:blank]]*$/d

4. 删除开头第一个字符为"#" 或"."的行

/^[\.#]/d

5. 将连续空格符替换成一个空白


s/ */ /g

或
s/ \{2,\}/ /g


6. 将第11到20行中的所有"abc"字样都替换成"def"

11,20s/abc/def/g


7. 将第11到20行中的所有"a","b","c"字符分别转换成"@"


11,20y/abc/@@@/


正则表达式的启发范例

锚点(anchor)


"锚点"(anchor)用于描述位置信息，也就是代表输入字符串中的特定位置。


范例

１．找出file1文件中以"Linux"字样开头的行


grep '^Linux' file1

2. 找出file1文件中以'x' 字符结尾的行：


grep 'x$' file1
3.计算file1文件中的空白行的行数


grep -c '^$' file1


4.找出file1文件中整行只含"oreilly" 这几个字母的行

grep '^oreilly$'  file1



字符类与列举范围


字符可以被分组归类与划分范围，以便正则表达式更有效率

范例


１．找出file1文件中任何含有"Linux","linux","Turbolinux"或诸如
此类字样的行


grep '[Ll]inux' file1

2.找出file1文件中任何含有三个相邻数字(例如，"123","77888")的行”

grep '[0-9][0-9][0-9]' file1


或以POSIX  字符类来表示：


grep '[[:digit:][:digit:][:digit:]]]' file1


3. 找出file1文件宏第一个字符不是数字的行

grep '^[^0-9]' file1


4.从file1文件中找出任何含有"Linux" 或"linux"的行，但它们必须是独立的
单词，而不可以是"LinuxOS" 

grep '\<[Ll]inux>\' file1


5. 从file1文件中找出任何含有连续五个字符(\n字符除外)的行：

grep '.....'　file1


6. 找出file1文件中的所有非空白行

grep '.' file1


7. 从file1文件中找出含有"." 字符的行

grep "\." file1


修饰符


修饰符(modifier)的作用是改变其修饰模式的含义。大多数修饰符都是描述目标
模式重复出现的次数，这类修饰符通常为"量词"


范例


１．找出file1文件中含有"ab","abc","abcccc"等行

grep "abc*" file1


3. 找出file1文件中含有两个以上相邻数字的行

grep '[0-9][0-9][0-9]*' file1

或
grep '[0-9]\{2,\}' file1

4. 找出file1文件中含有"file", "file1" 或"file2"字样的行

grep 'file[12]\?' file1


5.找出file1文件中至少含有一个数字的行

grep '[0-9]\+' file1


6. 从file1文件中找出整行文字是"111","111" 的行

grep '^1\{3,5\}$' file1


7.从file1文件中找出任何含有三、四或五位数字的行。数字本身必须自成一个单词

grep '\<[0-9]\{3,5\}\>' file1


8.显示file1 文件中含有"Happy","happy","Sad"

grep -E '[Hh]appy| [Ss]ad | [Aa]ngry' file1


9.显示file1文件中含有"abc"重复序列(例如，"abcabc","abcdabcd"等)的文段


grep '\(abc\)\{2.\}' file

103.8 vi的基本编辑操作

几乎所有系统管理工作最终都需要编辑配置我文件，用vi

启动vi
vi filename


基本操作
vi编辑器有两种操作模式：
命令模式(command mode)与插入模式(insert mode)

按 i 键，插入模式
按 Escape键， 命令模式



移动光标，翻页


进入命令模式




按键组合   说明


ctrl + b      翻移到前一页画面(backward)
ctrl + f      翻移动到下一也画面(forward)
0(零)         将光标移到文件的第一行
^            将光标移到当前行的第一个非空格符
&            将光标一道当前行的末尾
b             将光标移到前一个(左或上)单词
w             将光标移到后一个(右或下)单词
G             将光标移到文件尾
h             将光标向左移动一个字符
i             将光标移到下一行
k            将光标移到上一行
l           将光标向后移动一个字符
L           将光标移到当前页面的底部
H          将光标移到当前页面的顶端



编辑


典型文本编辑器该有的标准功能，诸如复制，粘贴，搜索等


Esc 从插入模式回到命令模式。
i    进入插入模式(离开命令模式)
I     先光标移到行收，然后进入插入模式
a     先将光标移到下一个字符，然后进入插入模式
A	先将光标移到行尾，然后进入插入模式  
o     
O
R
r
X
x
s
S
dd
D
cX
yX
yy 或Y
p
P
.
u


/pattern  往前搜索pattern
?pattern  往后搜索pattern


n     寻找下一个匹配模式的文段
N     反方向(向前)  寻找下一个匹配模式的文段


离开 vi


:n  切换到下一个文件
:q  不保存文件并离开
:q!  强制不保存文件并离开
:wq  保存文件并离开
:x      保存文件并离开
ZZ   保存文件并离开
:!cmd   启动一个subshell来执行cmd



