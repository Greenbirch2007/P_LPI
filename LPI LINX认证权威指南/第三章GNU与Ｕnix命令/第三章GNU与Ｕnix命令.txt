

第三章GNU与Ｕnix命令(共８章)
８２
本章主要涵盖了linux命令行工具的基本使用技能

GUI　图形用户界面


103.1:命令行环境的基本概念

适应命令行操作环境，具备能与shell和命令交互的基本技能
输入有效的命令，定义，使用与导出环境变量，操作历程记录(history)
与编辑功能，设定命令搜索路径，启动在搜索路径之处的命令，
使命令递归地处理整个目录树等



103.2　使用过滤器处理字符串流

要能使用GNU texttutils包里的工具来处理字符串流


103.3 基本的文件管理技巧

能够使用基本的文件操作命令，对文件与目录进行复制，移动，移除等
操作。还包括高级的文件管理操作，像是递归赋值多重文件，移除整个子目录树，
运用通配符(widcard)来移动文件，使用find来寻找符合某特定条件的文件等

103.4 流，管道与重定向的运用


流(stream)是Unix/Linux操作系统上最关键的概念之一，借由shell的管道
(pipe)与重定向(redirect)机制将多个小程序的I/O串接在一起，
使它们共同完成原本由个别程序无法办到的处理效果。
要有使用管道与重定向来构筑流的能力


103.5 进程的创建，监控与撤销


进程(process)是Unix/Linux的虫咬内核概念之一，如何管理长期运行的进程
是Linux系统管理者的重要课题。能够改变工作(job)的前台/后台运作状态，
启动不连续终端机的进程，使进程储蓄保持运行而不因启动该进程的用户注销
而中断，监视活动中的进程，传送信号(signal)给特定进程，辨识进程的运行
状态，终止运行中的进程等


103.6 调整进程的优先级

Linux是一个多用户多任务操作系统，为了让多个进程得以同时运行，对于
系统上活动的每一个进程，内核都各赋予其一个称为"优先级"(priority)
的参考值，此值会影响调度程序(scheduler)分配给进程的CPU时间的多寡。
如何修改进程的优先级，使其获得较多或较少的CPU时间配额

103.7 以正则表达式搜索文本文件

正则表达式(regular expression)是一种描述文件样式的语言，许多涉及
文字处理的工具都内置了正则表达式引擎，让你用语法来描述想要处理的文字样式。
运用grep,sed等工具来搜索或修改文件内容即可


103.8 vi的基本编辑凑走


能够使用vi对文本文件进行一些简单的编辑操作。

103.1 命令行环境的基本概念


用户界面(UI)是每种计算机系统的必要组件。对于Linux系统管理，通常
选择文本类型的用户界面(TUI).文本用户界面会以一个"提示符号"(prompt)
让用户/管理者知道，系统已经准备好接受命令的下达。
在提示符号之后，用户可键入一行或多行的文字命令。


负责提供提示符号并解释命令意义的程序统称为shell(壳)。因为这类程序是
系统与用户之间的接口，对用户而言，shell提供的环境就像计算机系统的外壳。
linux系统默认的shell是GNU参考sh所写出来的版本，称为bash(Bource-Again Shell)

Unix/Linux系统的shell不单是能够与用户交互的操作环境，同时还是一个强大的
程序设计环境


Shell操作环境你


当用户成功登录系统后，登录程序会自动启动shell,出现一个提示符$,#
有时，也有一些额外信息，比如主机名称，用户身份，当前的工作目录等

此时，表示shell已经准备好从它的标准输入(stdin)---键盘，接受你的命令

shell可以独立运行，就像在实体终端机上，也可以在GUI环境的窗口中运行

shell变量


在bash的运作期间，它会维护一组"shell变量"，这类变量含有bash运作时所需的
重要信息。大多数变量是在bash刚启动时就设定好，但是用户可随时动手改变设定值，
借此改变shell的行为表现


shell变量称为PS1(Prompt String 1),其值是一个代表"命令提示符号"的字符串。
既然有PS1,也会有PS2.它是bash在接受多行输入时，从第二行开始显示的提示字符串，
使用echo命令可显示变量的内容，方法是在变量名成之前加上一个$符号

echo $PS1

在此例子中，PS1字符串只含两个字符:\,$
\本身是一个特殊的字符，其作用是要求bash改变其后字符的解释方式：
当接在\之后的是元字符(meta characher),则解释为普通字符；
若是普通字符，则解释为元字符。
在此例子中，$本身是一个元字符，所以\$的意义是一个$符号

u,h,w本身都是普通字符，由于加了\
变为\u,\h,\W，所以bash将它们解释为元字符，其意义依序分别是
用户名称(username),
主机名称(hostname)
当前工作目录的名称(working directory)

提示符号的形式不影响shell对输入命令的解释

另一个会影响与shell交互的重要变量是PATH,也就是搜索路径(search path),
PATH变量值由一系列以冒号(:)隔开的路径所组成，当bash在搜索你
输入的命令时，会逐一依序到PATH所列的目录下去寻找。
在Linux系统启动期间，启动脚本(startup script)会将　典型的程序目录
纳入PATH变量，让你不必输入完整路径名称就可以启动大多数命令，
如果你将程序安装在PATH中找不到的目录，可以修改启动脚本，
使其包含你的程序目录


要让bash能够顺利找到并执行你在提示符号值所键入的命令，该命令必须：
１．是一个bash内置命令(命令本身是bash的一部分)，或
2.是一个可执行程序，其存放目录已列在PATH变量中，或
３．有明确的定义(即标明了完整的路径名称)


$元字符的作用是要求bash将其后的字符串视为变量名称，这就是为何要在
PS1变量名称之前加上$，否则echo会直接显示出"PS1"字符串，
而不是PS1变量的内容

shell变量不仅供自己使用，还可以供shell所启动的程序(包含其他shell(subshell))
使用。为了让其他程序也能取用shell变量。
它们必须被导出(export)成为环境变量(environment variable)
对于bash,PATH是当然的环境变量。
用于导出shell变量的命令是export

export MYVAR


环境变量会出现在所有子进程的环境变量中。由shell启动的所有程序都能够取用
父进程导出的环境变量


单行命令

在Linux系统上，用户对shell所下达的命令通常由四个部分组成：

１．一个有效的“命令”(shell的内置命令，存放于PATH所列目录中的程序，脚本
或是一个含有完整路径的程序文件名)

2.改变命令默认行为的“选项”。选项前通常会有一个破折号(-)
3.描述命令处理对象的"自变量"
4.触发机制(即按下Enter键，)

ls会列出工作目录下的所有内文件，

ls -l 列出详细的格式列出文件。在默认情况下，ls不会列出隐藏文件与隐藏目录
(名称第一个字符为.的文件或目录)。除非指定了-a选项，

列出ls -a 列出隐藏的文件

当需要改变命令的默认作用对象时，便必须加入自变量(argument)----有时也称为
参数(parameter).同样以ls为例，

查看当前目录下有哪些.c文件


ls -l *.c


ls --all*.c -l


由于有破折号的关系，ls可认出一个选项，而非文件名，并非
所有命令都强制要求选项之前一定要有破折号，最著名的例子是tar与ps
在这种情况下，选项与自变量的顺序就很重要

tar cf my f1 f2
tar -cf my f1 f2

都是将f1,f2封装成一个my文件。其中,f选项用来让tar直到，紧随其后的自变量
my是封装文件的文件名

linux命令范围极广，大多数系统管理者都会持续探索，复习自己常用的命令，
以学习还不熟悉的功能
定期查阅相关命令的man或info文件，是大多数系统管理者的标准学习模式


运行不在PATH中的程序

程序会被放在PATH所列目录之外的其他位置。运行这类程序，一个办法就是
在命令行指出程序文件的完整路径，假设要运行放在/opt/bin/目录下的ls程序

/opt/bin/ls


可以将/opt/bion目录(或用来放程序文件的其他目录)加入PATH变量：

export PATH="/opt/bin:#PATH"


之后，就直接输入命令
ls即可



shell会遵循搜索PATH变量中所列的每个目录并运行第一个找到的ls程序。
由于系统在开机期间会重新设定PATH变量，若要将你的新搜索路径延续到往后的
每一次开机，就得修改启动脚本

除了shell之外，还有一些程序也会到PATH所列的目录去寻找程序文件。因此
及时可以顺利地启动一个程序，但却可能会因为PATH所列的目录不够齐全，使得该程序无法
找到所需要的资源而导致运行失败


注意，
当前Linux系统的PATH变量默认值通常不含"当前工作目录"，这表示不能将工作目录
切换到程序所在的目录，然后以不含路径的程序的程序文件名来运行程序

除非该目录就已经被纳入PATH,要运行当前工作目录下的程序，必须在程序文件名
之前加./   例如./a.sh

PATH不含当前工作目录主要是基于安全考虑，


多行命令

Ｕnix系统的shell不仅能与用于交互，还具备程序语言能力，可以直接在名林航输入
跨越多行的shell　script。

例如，
在命令行输入for,until,while之类的循环结构时，及时按下了 Enter键，
bash峰会不断历史

与其自己重复键入相同的命令，不如以交互的方式使用bash的for循环结构处理

for var in ar1 ar2 ar3
do
echo $var
...一串命令...
done


如上的方式结合command-line(命令行)与shell-scripting(shell程序设计)


键入一组命令


在单一命令行同时下达多个命令，应该执行顺序键入每个命令，并以分号(;)
命令分隔符(command separator)，来将它们隔开

ls ; ps

应考技巧，注意命令行的选项和自变量的用法

命令历程与编辑

单独编写一个shell脚本

与bash交互时，所下达的每个命令会先被shell记录在自己的"历程表"(history list)
然后才开始进行解读与执行。
在里程表中的命令是命令的原样，不是展开通配符(*.?)之后的结果

历程表的容量由shell变量HISTSIZE所控制，
默认值是５００行，也可以调整
当你注销系统时，也就是shell变量HISTFILE所指定的文件。

当你下次登录系统时，仍然可以调出前次登录期间所输入的命令


使用bash的内置命令history可调出历程表。
会看到每个命令之前都被加注了行号，
用hisory所显示的行号。所谓的"历程扩展"，就是重新
执行历程表所记录的旧命令或旧命令的变异版本

历程扩展的语法


!!  代表历程表ｉ的最后一个命令。"bang-bang"
!n  代表历程表里的第n个命令，n就是history命令所显示的编号
!- n　　代表历程表中的倒数第n个命令
!string 代表历程表中最后一个开头为string的命令
!? string  代表历程表中最后一个含有string字样的命令
^string1^string2  重复最后一个名，但将命令中第一个出现的string1替换为string2


注意，在linux系统中, 惊叹号(!)常念成"bang"

注意，
如果在窗口环境同时启动多个shell，只有最后结束的shell才会将其历程表写入

使用"历程扩展"语法或上下方向键,调出历程表中的命令后，可以用命令行编辑
功能将旧命令改成想要的形式。
~/.bash_history。请选定其中一个shell来几种处理大部分工作，而且
这个shell必须最后结束


被重新执行的命令会自动成为历程表的一部分，


在bash的命令行，可以编辑器，移动，寻找，剪切，粘贴，来编辑调出的命令。




组合键


C -p 将光标往上移动一行
C -n  将光标往下移动一行
C -b　将光标往后移动一个字符
C -f　将光标往前移动一个字符
C -a　将光标移到行首(Home键)
C -e 将光标移到行尾(End键)
C -l 清楚画面并将当前的命令行移动到画面顶端(clear)


bash　也支持vi风格的编辑操作


M-<  移动到命令历程的顶端
M-> 移动到命令历程的尾端
C-d 往右删除一个字符(所删除的是光标所在位置的字符)
C-k　删除(kill)自光标所在位置开始至行尾间所有的文字
C-y　粘贴(yank)先前所剪切的文字
M-d  删除(kill) 一个单词
C-r text 反向查找text字符串
C-s text 正向查找text字符串


命令替换

bash 有命令替换(command substitution)的功能
可以让你将子命令的执行结果作为完整命令的一部分，
在编写脚本(script)时


子命令有两种可能的格式

$(subcmd)
'subcmd'


其中的subcmd可为任何有效的shell命令。
当bash遇到上面格式的子命令时，会将它们替换成subcmd的执行结果


$RCSIZE=$(wc -l -/bashrc)


上面的例子中，子命令四wc -l ~/.bashrc这部分，它会算出.bashrc文件的行数。
假设执行结果是20，就相当于

$RCSIZE=20


PS1="'whoami'@'uname -n' \$"

这个例子有两个命令，其中whoami会显示出当前用户的登录账号，而uname -n会
显示处理主机的网络结点名称，若上述命令放在网络主机为superlinux的bash
的启动脚本中，当john登录该系统时，会看到如下命令行提示符号：

john@superlinux $

两种命令替换语法的主要差异在于："subcmd"对于元符号的一些特殊处理规则是
$(subcmd)所不允许的；
此外，$(subcmd)的cmd可包含另一个$(subcmd)，但是
“subcmd”不允许多层的命令替换


最红，无论哪种形式，subcmd本身都是在subshell的环境中执行的，
若subcmd改变了任何变量，它们的效力会跟着subshell的消失而消失


递归地处理整个目录树


需要对整个目录树(directory tree)进行同样的处理动作，让命令的作用
对象跨越当前工作目录，扩及到整个子目录树。

如何让linux命令进行递归处理：有两种方法：
１．利用命令本身提供的递归选项(通常为 -r或-R),许多GNU命令本身都提供了
递归选项，以改变文件访问模式的chmod名

chmod g+w *.c


上述命令让同组成员可以写入工作目录下的所有.c文件。
现在，若要让同样的访问权限扩及当前工作目录下的所有目录里的.c文件，
可以运用chmod本身的-R选项(--recursive)

chmod -R g+w *.c


上面的效果相当于逐一进入每一个子目录来执行chmod g+w *.c

必须要有足够的而权限。除了chmod之外，还有薛国栋命令具有递归处理能力

包括，
cp 复制文件
ls　列出文件
rm　删除文件

如果命令没有递归处理能力，就使用find没你老公

find具有递归搜索能力，而且能执行另一个名

find的组合命令，可以对任何目录树进行几乎任何命令操作。
先从find的搜索能力开始


比如要处理对象是src/子目录下的任何文件

find src/


若只想处理src/目录的.c文件，则可用-name选项来描述我们想找的文件名样式

find src/ -name '*.c'


找出要处理的对象后，可以利用find的-exec选项，针对搜索的结果执行指定的命令。

-exec选项后接一系列字符串，最后必须以\;结尾


find src/ -name '*.c' -exec chmod g+w {} \;


上面的例子，对于每一个所找到的文件，find会分别执行一次chmod g+w {}mingl 

{}是一个特殊变量，它代表find所找到的文件的路径。

例如，find找到三个文件，

./src/p1.c
./src/p2.c
./src/p3.c

find会分别执行一次下列三个命令


chmod g+w ../src/p1.c
chmod g+w ../src/p2.c
chmod g+w ../src/p3.c


find也允许使用其他条件来搜索文件，像是问价你的最后一次修改日期，保护模式，
类型(文件，目录或链接)等

递归执行赋予了单一交谈式命令强大的能力，让它可以跨越当前目录(current directory)

103.2 使用过滤器处理字符串流
p94


