

第三章GNU与Ｕnix命令(共８章)
８２
本章主要涵盖了linux命令行工具的基本使用技能

GUI　图形用户界面


103.1:命令行环境的基本概念

适应命令行操作环境，具备能与shell和命令交互的基本技能
输入有效的命令，定义，使用与导出环境变量，操作历程记录(history)
与编辑功能，设定命令搜索路径，启动在搜索路径之处的命令，
使命令递归地处理整个目录树等



103.2　使用过滤器处理字符串流

要能使用GNU texttutils包里的工具来处理字符串流


103.3 基本的文件管理技巧

能够使用基本的文件操作命令，对文件与目录进行复制，移动，移除等
操作。还包括高级的文件管理操作，像是递归赋值多重文件，移除整个子目录树，
运用通配符(widcard)来移动文件，使用find来寻找符合某特定条件的文件等

103.4 流，管道与重定向的运用


流(stream)是Unix/Linux操作系统上最关键的概念之一，借由shell的管道
(pipe)与重定向(redirect)机制将多个小程序的I/O串接在一起，
使它们共同完成原本由个别程序无法办到的处理效果。
要有使用管道与重定向来构筑流的能力


103.5 进程的创建，监控与撤销


进程(process)是Unix/Linux的虫咬内核概念之一，如何管理长期运行的进程
是Linux系统管理者的重要课题。能够改变工作(job)的前台/后台运作状态，
启动不连续终端机的进程，使进程储蓄保持运行而不因启动该进程的用户注销
而中断，监视活动中的进程，传送信号(signal)给特定进程，辨识进程的运行
状态，终止运行中的进程等


103.6 调整进程的优先级

Linux是一个多用户多任务操作系统，为了让多个进程得以同时运行，对于
系统上活动的每一个进程，内核都各赋予其一个称为"优先级"(priority)
的参考值，此值会影响调度程序(scheduler)分配给进程的CPU时间的多寡。
如何修改进程的优先级，使其获得较多或较少的CPU时间配额

103.7 以正则表达式搜索文本文件

正则表达式(regular expression)是一种描述文件样式的语言，许多涉及
文字处理的工具都内置了正则表达式引擎，让你用语法来描述想要处理的文字样式。
运用grep,sed等工具来搜索或修改文件内容即可


103.8 vi的基本编辑凑走


能够使用vi对文本文件进行一些简单的编辑操作。

103.1 命令行环境的基本概念


用户界面(UI)是每种计算机系统的必要组件。对于Linux系统管理，通常
选择文本类型的用户界面(TUI).文本用户界面会以一个"提示符号"(prompt)
让用户/管理者知道，系统已经准备好接受命令的下达。
在提示符号之后，用户可键入一行或多行的文字命令。


负责提供提示符号并解释命令意义的程序统称为shell(壳)。因为这类程序是
系统与用户之间的接口，对用户而言，shell提供的环境就像计算机系统的外壳。
linux系统默认的shell是GNU参考sh所写出来的版本，称为bash(Bource-Again Shell)

Unix/Linux系统的shell不单是能够与用户交互的操作环境，同时还是一个强大的
程序设计环境


Shell操作环境你


当用户成功登录系统后，登录程序会自动启动shell,出现一个提示符$,#
有时，也有一些额外信息，比如主机名称，用户身份，当前的工作目录等

此时，表示shell已经准备好从它的标准输入(stdin)---键盘，接受你的命令

shell可以独立运行，就像在实体终端机上，也可以在GUI环境的窗口中运行

shell变量


在bash的运作期间，它会维护一组"shell变量"，这类变量含有bash运作时所需的
重要信息。大多数变量是在bash刚启动时就设定好，但是用户可随时动手改变设定值，
借此改变shell的行为表现


shell变量称为PS1(Prompt String 1),其值是一个代表"命令提示符号"的字符串。
既然有PS1,也会有PS2.它是bash在接受多行输入时，从第二行开始显示的提示字符串，
使用echo命令可显示变量的内容，方法是在变量名成之前加上一个$符号

echo $PS1

在此例子中，PS1字符串只含两个字符:\,$
\本身是一个特殊的字符，其作用是要求bash改变其后字符的解释方式：
当接在\之后的是元字符(meta characher),则解释为普通字符；
若是普通字符，则解释为元字符。
在此例子中，$本身是一个元字符，所以\$的意义是一个$符号

u,h,w本身都是普通字符，由于加了\
变为\u,\h,\W，所以bash将它们解释为元字符，其意义依序分别是
用户名称(username),
主机名称(hostname)
当前工作目录的名称(working directory)

提示符号的形式不影响shell对输入命令的解释

另一个会影响与shell交互的重要变量是PATH,也就是搜索路径(search path),
PATH变量值由一系列以冒号(:)隔开的路径所组成，当bash在搜索你
输入的命令时，会逐一依序到PATH所列的目录下去寻找。
在Linux系统启动期间，启动脚本(startup script)会将　典型的程序目录
纳入PATH变量，让你不必输入完整路径名称就可以启动大多数命令，
如果你将程序安装在PATH中找不到的目录，可以修改启动脚本，
使其包含你的程序目录


要让bash能够顺利找到并执行你在提示符号值所键入的命令，该命令必须：
１．是一个bash内置命令(命令本身是bash的一部分)，或
2.是一个可执行程序，其存放目录已列在PATH变量中，或
３．有明确的定义(即标明了完整的路径名称)


$元字符的作用是要求bash将其后的字符串视为变量名称，这就是为何要在
PS1变量名称之前加上$，否则echo会直接显示出"PS1"字符串，
而不是PS1变量的内容

shell变量不仅供自己使用，还可以供shell所启动的程序(包含其他shell(subshell))
使用。为了让其他程序也能取用shell变量。
它们必须被导出(export)成为环境变量(environment variable)
对于bash,PATH是当然的环境变量。
用于导出shell变量的命令是export

export MYVAR


环境变量会出现在所有子进程的环境变量中。由shell启动的所有程序都能够取用
父进程导出的环境变量


单行命令

在Linux系统上，用户对shell所下达的命令通常由四个部分组成：

１．一个有效的“命令”(shell的内置命令，存放于PATH所列目录中的程序，脚本
或是一个含有完整路径的程序文件名)

2.改变命令默认行为的“选项”。选项前通常会有一个破折号(-)
3.描述命令处理对象的"自变量"
4.触发机制(即按下Enter键，)

ls会列出工作目录下的所有内文件，

ls -l 列出详细的格式列出文件。在默认情况下，ls不会列出隐藏文件与隐藏目录
(名称第一个字符为.的文件或目录)。除非指定了-a选项，

列出ls -a 列出隐藏的文件

当需要改变命令的默认作用对象时，便必须加入自变量(argument)----有时也称为
参数(parameter).同样以ls为例，

查看当前目录下有哪些.c文件


ls -l *.c


ls --all*.c -l


由于有破折号的关系，ls可认出一个选项，而非文件名，并非
所有命令都强制要求选项之前一定要有破折号，最著名的例子是tar与ps
在这种情况下，选项与自变量的顺序就很重要

tar cf my f1 f2
tar -cf my f1 f2

都是将f1,f2封装成一个my文件。其中,f选项用来让tar直到，紧随其后的自变量
my是封装文件的文件名

linux命令范围极广，大多数系统管理者都会持续探索，复习自己常用的命令，
以学习还不熟悉的功能
定期查阅相关命令的man或info文件，是大多数系统管理者的标准学习模式


运行不在PATH中的程序

程序会被放在PATH所列目录之外的其他位置。运行这类程序，一个办法就是
在命令行指出程序文件的完整路径，假设要运行放在/opt/bin/目录下的ls程序

/opt/bin/ls


可以将/opt/bion目录(或用来放程序文件的其他目录)加入PATH变量：

export PATH="/opt/bin:#PATH"


之后，就直接输入命令
ls即可



shell会遵循搜索PATH变量中所列的每个目录并运行第一个找到的ls程序。
由于系统在开机期间会重新设定PATH变量，若要将你的新搜索路径延续到往后的
每一次开机，就得修改启动脚本

除了shell之外，还有一些程序也会到PATH所列的目录去寻找程序文件。因此
及时可以顺利地启动一个程序，但却可能会因为PATH所列的目录不够齐全，使得该程序无法
找到所需要的资源而导致运行失败


注意，
当前Linux系统的PATH变量默认值通常不含"当前工作目录"，这表示不能将工作目录
切换到程序所在的目录，然后以不含路径的程序的程序文件名来运行程序

除非该目录就已经被纳入PATH,要运行当前工作目录下的程序，必须在程序文件名
之前加./   例如./a.sh

PATH不含当前工作目录主要是基于安全考虑，


多行命令

Ｕnix系统的shell不仅能与用于交互，还具备程序语言能力，可以直接在名林航输入
跨越多行的shell　script。

例如，
在命令行输入for,until,while之类的循环结构时，及时按下了 Enter键，
bash峰会不断历史

与其自己重复键入相同的命令，不如以交互的方式使用bash的for循环结构处理

for var in ar1 ar2 ar3
do
echo $var
...一串命令...
done


如上的方式结合command-line(命令行)与shell-scripting(shell程序设计)


键入一组命令


在单一命令行同时下达多个命令，应该执行顺序键入每个命令，并以分号(;)
命令分隔符(command separator)，来将它们隔开

ls ; ps

应考技巧，注意命令行的选项和自变量的用法

命令历程与编辑

单独编写一个shell脚本

与bash交互时，所下达的每个命令会先被shell记录在自己的"历程表"(history list)
然后才开始进行解读与执行。
在里程表中的命令是命令的原样，不是展开通配符(*.?)之后的结果

历程表的容量由shell变量HISTSIZE所控制，
默认值是５００行，也可以调整
当你注销系统时，也就是shell变量HISTFILE所指定的文件。

当你下次登录系统时，仍然可以调出前次登录期间所输入的命令


使用bash的内置命令history可调出历程表。
会看到每个命令之前都被加注了行号，
用hisory所显示的行号。所谓的"历程扩展"，就是重新
执行历程表所记录的旧命令或旧命令的变异版本

历程扩展的语法


!!  代表历程表ｉ的最后一个命令。"bang-bang"
!n  代表历程表里的第n个命令，n就是history命令所显示的编号
!- n　　代表历程表中的倒数第n个命令
!string 代表历程表中最后一个开头为string的命令
!? string  代表历程表中最后一个含有string字样的命令
^string1^string2  重复最后一个名，但将命令中第一个出现的string1替换为string2


注意，在linux系统中, 惊叹号(!)常念成"bang"

注意，
如果在窗口环境同时启动多个shell，只有最后结束的shell才会将其历程表写入

使用"历程扩展"语法或上下方向键,调出历程表中的命令后，可以用命令行编辑
功能将旧命令改成想要的形式。
~/.bash_history。请选定其中一个shell来几种处理大部分工作，而且
这个shell必须最后结束


被重新执行的命令会自动成为历程表的一部分，


在bash的命令行，可以编辑器，移动，寻找，剪切，粘贴，来编辑调出的命令。




组合键


C -p 将光标往上移动一行
C -n  将光标往下移动一行
C -b　将光标往后移动一个字符
C -f　将光标往前移动一个字符
C -a　将光标移到行首(Home键)
C -e 将光标移到行尾(End键)
C -l 清楚画面并将当前的命令行移动到画面顶端(clear)


bash　也支持vi风格的编辑操作


M-<  移动到命令历程的顶端
M-> 移动到命令历程的尾端
C-d 往右删除一个字符(所删除的是光标所在位置的字符)
C-k　删除(kill)自光标所在位置开始至行尾间所有的文字
C-y　粘贴(yank)先前所剪切的文字
M-d  删除(kill) 一个单词
C-r text 反向查找text字符串
C-s text 正向查找text字符串


命令替换

bash 有命令替换(command substitution)的功能
可以让你将子命令的执行结果作为完整命令的一部分，
在编写脚本(script)时


子命令有两种可能的格式

$(subcmd)
'subcmd'


其中的subcmd可为任何有效的shell命令。
当bash遇到上面格式的子命令时，会将它们替换成subcmd的执行结果


$RCSIZE=$(wc -l -/bashrc)


上面的例子中，子命令四wc -l ~/.bashrc这部分，它会算出.bashrc文件的行数。
假设执行结果是20，就相当于

$RCSIZE=20


PS1="'whoami'@'uname -n' \$"

这个例子有两个命令，其中whoami会显示出当前用户的登录账号，而uname -n会
显示处理主机的网络结点名称，若上述命令放在网络主机为superlinux的bash
的启动脚本中，当john登录该系统时，会看到如下命令行提示符号：

john@superlinux $

两种命令替换语法的主要差异在于："subcmd"对于元符号的一些特殊处理规则是
$(subcmd)所不允许的；
此外，$(subcmd)的cmd可包含另一个$(subcmd)，但是
“subcmd”不允许多层的命令替换


最红，无论哪种形式，subcmd本身都是在subshell的环境中执行的，
若subcmd改变了任何变量，它们的效力会跟着subshell的消失而消失


递归地处理整个目录树


需要对整个目录树(directory tree)进行同样的处理动作，让命令的作用
对象跨越当前工作目录，扩及到整个子目录树。

如何让linux命令进行递归处理：有两种方法：
１．利用命令本身提供的递归选项(通常为 -r或-R),许多GNU命令本身都提供了
递归选项，以改变文件访问模式的chmod名

chmod g+w *.c


上述命令让同组成员可以写入工作目录下的所有.c文件。
现在，若要让同样的访问权限扩及当前工作目录下的所有目录里的.c文件，
可以运用chmod本身的-R选项(--recursive)

chmod -R g+w *.c


上面的效果相当于逐一进入每一个子目录来执行chmod g+w *.c

必须要有足够的而权限。除了chmod之外，还有薛国栋命令具有递归处理能力

包括，
cp 复制文件
ls　列出文件
rm　删除文件

如果命令没有递归处理能力，就使用find没你老公

find具有递归搜索能力，而且能执行另一个名

find的组合命令，可以对任何目录树进行几乎任何命令操作。
先从find的搜索能力开始


比如要处理对象是src/子目录下的任何文件

find src/


若只想处理src/目录的.c文件，则可用-name选项来描述我们想找的文件名样式

find src/ -name '*.c'


找出要处理的对象后，可以利用find的-exec选项，针对搜索的结果执行指定的命令。

-exec选项后接一系列字符串，最后必须以\;结尾


find src/ -name '*.c' -exec chmod g+w {} \;


上面的例子，对于每一个所找到的文件，find会分别执行一次chmod g+w {}mingl 

{}是一个特殊变量，它代表find所找到的文件的路径。

例如，find找到三个文件，

./src/p1.c
./src/p2.c
./src/p3.c

find会分别执行一次下列三个命令


chmod g+w ../src/p1.c
chmod g+w ../src/p2.c
chmod g+w ../src/p3.c


find也允许使用其他条件来搜索文件，像是问价你的最后一次修改日期，保护模式，
类型(文件，目录或链接)等

递归执行赋予了单一交谈式命令强大的能力，让它可以跨越当前目录(current directory)

103.2 使用过滤器处理字符串流

linux系统上有很多统称为过滤器(filter)的工具，它们可以从自己的标准输入(stdin)
或其他文件送入字符串流(text stream)加以修正，最后送往标准输出(stdout)
或存入新文件。

可用管道(pipe)将不同功能的过滤器串接在一起，使他们通力达成单个
过滤器办不到的修整效果。


cut 

cut options [files]

说明

将输入行的特定字段"裁切"出来(显示出来)。在默认情况下，cut将tab视为
字段分隔字符，除非你以-d选项执行其他分隔字符。cut影响原始输入文件


常用选项


cut -d list
cut -c list
cut -d delim
cut -f list



cut -d list

	显示出位于list所指定位置的字节。list是一连串以逗号分隔的数字，
		位置是以byte为计算单位
	
cut -c list

	显示出位于list所指位置的字符。list是一连串以逗号分隔的数字，
	位置是以column(字段)为计算单位

cut -d delim

	定义字段分隔符为delim字符
cut -f list

	显示出list所列出的字段。list是一连串以逗号分隔的数字，代表字段你的编号


例子


1.显示/etc/passwd文件(以冒号作为分隔符)中的第一个字段(用户名称)

cut -d: -f1 /etc/passwd

2.显示/etc/passwd 文件每行的第一个字段


cut -c 1 /etc/passwd


expand 

	expand [options] files

说明
	将输入流中的tab字符转换成等宽的若干个space字符。虽然tab有助于
	排齐文本，但并非所有输出设备对于tab的解释都一样。所以，在某终端
	机(或编辑器)上在其他地方可能很乱，解决办法是将tab字符换成适当
	数量的space字符。
	在默认情况下，expand假设一个tab字符的定位效果相当于8个空格

常用选项


expand -t number
expand -i


expand -t number

	指定tab字符的等效空格宽度(默认值为８)

expand -i
	只转换出现在行首的tab字符


fmt 
	fmt [options] [files]

说明
	将文稿编排成指定的宽度。过长的行会被换到下一行(安插一个\n字符)，
	过短的行会被连接到前一行末尾(移除前一行末尾的\n字符)。
	如果同时指定多个文件，则将所有文件的内容都视为连续的字符串流


常用选项

fmt -u
fmt -w width


fmt -u
	使用一致的间隔方式：单字(词)之间隔１个空格，句子之间间隔2个空格

fmt -w width
	将版面宽度(每行的字数)设为width,默认为75


head 
	head [options] [files]


说明
	显示出文件开头的前几行，。若同时指定多个文件，于每个文件开头处内容
	之前会多显示一个标头，以便区分


head -c n
head -n m


head -c n
	显示出前n个字节的内容。若n后面附加了k或m,则计算单位将会相应变成
	千字节(KB)或兆字节(MB)

head -n m
	显示出头m行的内容，默认值为10



join

	join [options] file1 file2


说明

	依据所指定的字段将来自file1与file2的两个表格合并成一个表格


join -j1 nfield
	索引字段为file1的第nfield个字段

join -j2 nfield
	索引字段为file1的第nfield个字段
join -j field
	将file1与file2共同的field视为索引字段



范例

join -j 1 file1 file2


nl

	nl [options] [files]

说明

	为files里的每一行加上行号。nl主要是用于给"正文"编行号，
	所以它提供了特殊的页眉(header)与页脚(footer)选项，让你
	将这些原本不应该被编号的文本行排除在外。
	每个逻辑页面(logical page)的第一行的内容编号为1
	一个逻辑页眉是由页眉，内容，页脚三个部分组成，
	这三个部分依次序由特殊字符串 \:
	
常用选项


nl -b style
nl -f style
nl -h style
nl a
nl t
nl n


nl -b style
	设定内容的编号方式，默认方式为t(只有非空白才有编号)
nl -f style
	设定页脚的编号方式，默认方式为n(无编号)
nl -h style
	设定页眉的编号方式，默认方式为n(无编号)

各种编号方式如下：

nl a
	全部编号，包括空白行
	
nl t
	只编号非空白行
nl n
	完全不编号

pREGEXP  
	只有匹配REGEXP正则表达式的文本行才编号


范例


假设文件file1的内容如下

nl -h a file1

只有页眉与内容才有编号，而页脚没有。每隔一个逻辑页面就会重新编号

od
	od [options] [files]

说明
	以八进制(octal)数值格式显示文件内容。od主要用于显示binary文件
	的字节编码。除了八进制之外，也可以选择ASCII,十六进制等表示格式。


常用选项

od -t type
od -ta
od -tc
od -to
od -tx


od -t type
	选择字节的表示格式。各种type的意义如下
od -ta
	字符名称(例如，00表示nul)
od -tc
	ASCII或backslash escape(例如，00表示成\0,65表示成A)
od -to
	八进制数值(默认)

od -tx
	十六进制数值


文本中的内容
\n 是ASCII newline字符。以a格式显示此文件

od -t a file1

每行开头的那一长串八进制数值的数字代表该行数据在文件中的相对位置，其后才是
数据本身的表达方式。由于我们要求以"字符名称"来表示，所以\n被显示为nl(new line的缩写)

paste

	paste [options] files

说明
将一个或多个文件的内容横向排列在一起。每个输入文件的第一行都将称为
合并结果的第一行的独立字段


常用选项


paste -d "n"

paste -s



paste -d "n"
	以n为字段分隔字符(默认的分隔字符是tab)

paste -s
	将输入文件的内容纵向列在一起。有多个输入文件时，每个文件的内容自称一行



合并两个文件的内容，pastee所产生的输出(横向排列)为：

paste f1 f2

使用-s选项时，paste所产生的输出(纵向排列)为

paste -s f1 f2


使用-d选项将字段分隔字符从tab改为@


paste -d '@' f1 f2



pr
	pr [options] [file]

说明

将文本文件的内容转换成分页，分段的版本，并且另外加上页眉与页尾。
页眉可还有日期，时间，文件名以及页码的等信息。
pr主要用于在"原样打印机"(没有打印机语言的原始打印机)产生漂亮的
输出字符串流


常用

pr -d
pr -h header
pr -l lines
pr -o width


pr -d
	两倍间距
pr -h header
	以header替换页眉中的文件名

pr -l lines
	将页面的长度设为lines,默认为66行，最低为10行
	
pr -o width
	将页面左边留白宽度设定为width


sort

	sort [options] [files]

说明
读取输入内容，以字母顺序(或你指定的其他顺序)输出它们

常用选项
sort -f 
sort -n
sort -r
sort -kpos1[,pos2]
sort -t 
sep为区别键值的分隔字符(默认值为空格符)

sort -f 
	不区分大小写字母的差异
sort -n
	以数值顺序排列
sort -r
	以相反顺序排列。不指定-r选项时，默认以升序排列

sort -kpos1[,pos2]
	以位于pos1(到pos2)的键值为排序依据
sort -t　sep
	
sep为区别键值的分隔字符(默认值为空格符)



例子
１．显示系统进程，以常驻部分的大小(ps输出信息中的RSS字段)顺序列出它们


ps aux | sort -k 6 -n


split
	split [options] [infile] [outfile]

说明
split可将大文件分割成若干个小文件。它先读出infile的内容，每隔1000行
(或你指定的行数)就写入一个新文件。
新文件以outfileaa,outfileab,等顺序来命名


以往通过电子邮件发送大型文件时，常会用此命令将大文件分割成一组
小文件以便分开发送。因为一次发送整个大型的电子邮件信息被视为一种不友善的行为


常用选项

split -n 
	每隔n(默认值为1000)行就分成一个新文件


split -2 file1 splitout_


将会产生三个新文件:splitout_aa,splitout_ab与splitout_ac

tac

	tac [file]

说明

	颠倒输入行的顺序，刚好与cat命令的效果相反(所以取名为tac)

范例

tac file1


tail
	tail [options] [files]

说明
显示出一个或多个文件中的最后几行。同时指定多个文件时，于每个文件的内容
之前会先出现该文件的文件名以作区分


常用选项

tail -c n
tail -f
tail -n m


tail -c n
	显示出文件中最后n个字节的内容，若n后面附加了k或m,则计数单位将会相应
	变成千字节(KB)或兆字节(MB)
tail -f
	显示出文件尾端内容后不关闭输入文件，并且在输入文件的末端出现新呢荣
	时实时将它们显示出来。管理者常用此选项来持续观察日志文件的内容变化情况
tail -n m

	显示出最后m行的内容，默认值为１０


tr
	tr [options] [[string1 [string2]]


说明
将string1里的字符转译成string2里相应的字符。tr本身没有file自变量，其数据
来源固定为stdin,输出目标固定为stdout.
如果string1与string2是范围的形式(a-z或A-Z),那么这两个范围所涵盖的
字符树木必须相同

string1和string2都可以含有多种特殊字符


a-z 从a到z的所有字符
\\　代表\字符本身
\nnn　ASCII编码值为nnn(八进制表示法)　的字符
\x　各种控制字符
\a　响铃(bell)
\b 倒退(backspace)
\f 进纸(form feed)
\n 换行(new line)
\r 回车(carriage return)
\t 横跳格(tab)
\v 纵跳格(vertical tab)


[:class:] POSIX字符类组
[:alnum:]　字母数字(字母与数字)
[:alpha:]　字母
[:blank:]　空格(space或tab)
[:cntrl:] 控制字符
[:digit:]　数字
[:graph:]　可显示字符(不含space)
[:lower:] 小写字母
[:print:]　所有可显示字符(含space)
[:punct:] 标点符号
[:space:]　任何空格符
[:upper:]　大写字母
[:xdigit:]十六进制数字


常用选项


tr -c
tr -d
tr -s


tr -c
	以相反意义解释string1
tr -d
	丢弃出现于string1中的任何字符

tr -s
	若输入数据中连续出现string1所含的任一字符，则将连续字符挤压(squeeze)
	到只剩一个


范例


１．将f1中的所有小写字符转换成大写字符

cat f1 | tr a-z A-Z


或

tr a-z A-Z < f1


２．　消除f1中连续的字符a(只留下一个):
cat f1 | tr -s a


3. 移除f1中所有的字符a,b,c:

cat f1 | tr -d abc



unexpand
	unexpand [options] [files]


说明
将输入文件中的space字符转换成tab字符。默认情况下，它假设tab的位置
是相隔８个space字符


常用选项


unexpand -a
unexpand -t number


unexpand -a
	转换所有space,而非只有每行开头处的space.通常，unexpand不会动刀
	正规文字开始之后的空格

unexpand -t number
	指定tab空白宽度(默认为8)



uniq

	uniq [options] [input[output]]


说明

读入stdin,消除连续的相同文本行，然后写到stdout.由于uniq只处理相邻的文本
行，所以通常搭配sort一起使用(sort可使所有相同的文本行都聚集在一起)


常用选项

uniq -d
uniq -u


uniq -d
	只显示出有重复的文本行
uniq -u
	只显示出不重复的文本航


剔除重复的

uniq f1



因为uniq只处理相邻的重复行。要彻底消除输入文件中的所有重复行，
必须事先用sort将重复行整并在一起：

sort file | uniq

若想查出哪些行是重复的，可以使用-d选项

sort file | uniq -d



wc

	wc [options] [files]

说明
计算files文件内容的字符数(char),单词数(word)与行数(line).
同时指定多个文件时，则分别统计各个文件的字数并分行显示各文件的
数据，最后一行则显示各项累加值


常用选项

wc -c
wc -l
wc -w

wc -c
	只显示出字符数
wc -l	
	只显示出行数
wc -w
	只显示出单词数


例子

1.命令统计f1,f2,f3，这三个文件的字符数，行数，单词数以及三项数据的综合


wc f[123]


2.计算当前工作目录下有多少个文件

ls | wc -l

先用ls列出当前工作目录下的文件，然后利用wc计算行数的能力计算出文件数


xargs

	xargs [options] [other_cmd]  [initial_arguments]

说明
将来自stdin的数据逐一作为other_cmd的自变量，逐次执行新构成的命令，
直到耗尽stdin为止。如果要执行的新命令有固定的选项或参数，则可以在
initial_arguments予以指定。从stdion读入的参数会接在initial_arguments之后

xargs主要是用来解决命令行过长的问题
或需要从其他命令的执行结果得到所要执行命令的自变量


常用选项


xargs -n maxargs
xargs -p


xargs -n maxargs
	限制每次传给other_cmd的额外自变量的数量
xargs -p
	交互模式。执行新构成的other_cmd之前会提示用户进行确认



范例

1.要想用rm删除某个目录下的所有文件,rm *

如果文件太多，可能超过shell能接受的命令行长度限制。
ls | xargs rm


2. 要在不同位置的文件中找出含有特定字符串(例如,"gg")的文件。
用于匹配文件内容的工具是grep
但是所需的文件名自变量刚好是要寻找的对象。
对于这种情况，可用find列出搜索范围内的所有文件，
然后通过管道由xargs代为产生并执行grep命令来匹配字符串


find / -type f | xargs -n 1 grep gg




上面的例子，find从根目录(/)找出type(类型)为f(文件)的文件(排除目录，链接
socket等特殊文件)，每当xargs从自己的stdin(已被管道接到find的stdout)
得到一个文件名(因为-n 1的关系)时，
就构建并执行了一次grep gg　filename命令

１０３．３　基本的文件管理技巧


对于文件系统的基本操作与管理是Linux用户绝对必要的技能


文件系统的基本操作技术，包括关于文件系统的基本概念，通配符以及涉及文件系统的各种标准管理工具
文件系统

linux的"文件系统"相当于 windows的"分区类型"(partition type)

linux也有“目录树”(directory tree) 


几乎每种操作系统都是以"层次结构"(hieracrhy)来组织其需要保存的对象，以“树状结构”来组织对象。

树状结构的好处之一，是有限度地允许同名对象的存在(只要它们最近的上层结点不同即可)

以“层次结构”理念设计出来的文件系统允许不同文件可以具有相同名称，只要它们不再同一个目录下即可。

因为linux是一个多用户多任务操作系统，不能因为某个用户选择了某个文件名，就剥夺了其他用户也选择该文件名的权利



文件系统对象

存储于文件系统上的对象(文件，目录，socket,链接...)的相关信息(标识符，名称，类型，大小，于磁盘上的位置，拥有者，访问权限...)
是记录在"文件系统表"中。此表本身是文件系统的一部分，其具体的结构定义随文件系统的类型而已。

linux系统中常见的文件系统类型包括ext2,ext3,Reiser FS,XFS等。

不过，对于用户而言，不同文件系统类型之间的主要差异并非"文件系统表"，而在于它们所表现出来的访问效率，容错能力，存储空间利用率等

虽然linux支持多种文件系统类型，它们都同样能够存储POSIX(Linux所遵循的操作系统标准)所规定的对象并以树状结构呈现这些对象。

最常见的两种文件系统对象是"目录"与"文件"


目录与文件

"目录"(directory)是一种用来容纳其他对象的对象，"文件"(file)则是一种用来容纳数据对象。

各目录之间的从属关系就是一个树，位于树状结构顶端的目录称为根目录(root directory)，其作用是容纳目录树的第一层对象。

描述跟目录的符号是"/"，它同时也是对象名称之间的分隔符号。
以ls命令的程序文件/bin/ls为例，
这表示该命令的实质程序代码是放在跟目录下的bin目录下的ls文件里



Inode


文件系统上的每一个对象的识别信息都记录于一种称为inode的数据结构中。
inode所记录的对象信息包括对象类型，在磁盘上的位置，修改时间，访问权限等
对于inode的组织与管理方式，随文件系统的类型(ext2,ext3...)而定。
当你使用mkfs.fstype制作文件系统时，其实就是将inode结构写入磁盘分区。对于Linux系统上常见的ext2文件系统，mkfs.ext2会预先配置一定
数量的inode.Linux文件系统还允许多个对象共享同一个inode.
此概念就是一般的"链接"(linking)

管理文件与目录的命令行工具

linux提供了一组管理文件与目录的命令，可以让用户用来创建，读取，修改，复制，连接，移动，或删除对象

linux GUI环境也提供了管理文件与目录的工具。命令行工具才是linux系统的精髓，也是考试重点


cp 

 cp [options] file1 file2
 cp [options] files directory

说明

可以复制或覆盖到file2。file1与file2可以是任何有效的文件名称，可以是完整的的路径明后才能或相对与当前工具目录的文件名

第二种形式会将一个或多个files复制到directory下。同时指定两个以上的自变量时，cp会假设最后一个自变量是目的地，


常用选型

cp -f
cp -i
cp -p
cp -rR
cp -v


cp -f
	强制覆盖现有的目标文件

cp -i
	覆盖目标文件之前先提示用户进行确认。
	
cp -p
	保留文件的所有属性信息，包括拥有者，组，使用权限以及时间戳。若未指定此选项，则未指定此选项，则新文件的属性将一下法则来设定：以
当前时间为最后修改时间，以权限位为操作者默认的访问模式，以拥有者与组为用户本身与用户所属的组


cp -rR
	递归复制整个子目录树。此选项的大小写形式是等效的。指定此选项的情况下，如果file1是目录而非文件，则会产生一个file2目录，其内容是file1
子目录树的完整副本
cp -v
	在复制进行之前先显示文件名称

范例

1.将系统日志文件(/var/log/messages)复制到当前目录下(以.表示)：

cp /var/log/messages . 


2. 将整个src子目录树复制到另一个新的src2子目录树保留所有文件属性

cp -Rp src src2


3. 将当前目录下的file1.file2,file5，file6,file7文件复制到个人目录下：

cp file1 file2 file[567]


应考诀窍：

弄清楚cp如何解读自变量，以及该如何强制覆盖现有文件或是如何避免无意覆盖现有文件


mkdir [options] directions

说明

创建一个或多个directories.你必须拥有新目录的上层目录的写入权限。


常用选项

mkdir -m mode
mkdir -p


mkdir -m mode
	将direcories的权限模式设为mode
mkdir -p
	创建direcories时自动创建不存在的中间层目录


范例

1.创建一个名为personal的新目录并将其权限设定为全部只读

mkdir -m 444 personal

2. 于自己个人目录(以～表示)下创建一个三层子目录树：
mkdir -p ~/dir1/dir2/dir3


上面的例子，若dir1不存在，则会依序自动创建 ~/dir1,~-dir1/dir2,~/dir1/dir2/dir3三个目录

应考诀窍

记住bash允许使用~符号表示用户自己的个人目录


mv
语法
mv [options] source target

说明对文件或目录进行移动或重命名。如果target的位置与source位于相同的文件系统(磁盘分区)，移动操作并不会改变文件内容
原本的存储位置，而是改变source所属的上层目录(相当于改变source的名称)；
但如果target与source 位于不同的文件系统，则source的内容会被复制到新位置，然后才删除掉source

注意

文件与目录的重命名操作也会使用mv,重命名操作需要更新(同一个)目录的数据项


如果target文件或目录不存在，那么source便会被重命名为target。如果target是一个现有的文件，那么
她会被source所覆盖；如果target是一个现有的目录，那么source便会被移往该目录；假设source是一个或多个文件，而
target是一个目录，那么这些文件都会被移往该目录


常用选项


mv -f
mv -i


mv -f
	强制完成移动，如果target存在，则会抑制警告信息的显示
mv -i
	移动文件之前提示用户进行确认

应考诀窍

对同一个文件系统(单一的磁盘分区)而言，"重命名"与"移动"其实是一样的操作，所以没必要另备专供重命名用的rename命令

rm

语法
	rm [options] files


说明

从文件系统中删除一个或多个files.对于要被移除的我呢间，你必须对该文件所属的目录拥有
写入的权限。
不必对该文件本身拥有写入权限。


常用选项

rm -d
rm -f
rm -i
rm -r -R


rm -d
	即使不是空目录，也强制移除掉。用户必须具备特殊权限
rm -f
	强制移除设有写保护的文件，而且不提示任何警告信息
rm -i
	移除文件之前提示用户进行确认
rm -r -R
	如果file是一个目录则递归地移除整个子目录树


rmdir


语法
	rmdir [option] directions

说明
删除空的directions



常用

rmdir -p
	连同中间层目录也一并删除。此选项可用来移除子目录树。

应考诀窍

rmdir删除尚含有文件的目录，但是使用rm -R则可以将目录树本身与所含的文件一并清除


touch

语法
	touch [options] files

说明
变更files的访问时间，修改时间。程序员常用touch来改变文件的时间戳以制造文件内容曾被修改修改过的假象(其实文件内容没变)
而使得make重新编译被touch 的程序文件


常用选项


touch -a
	只将文件的内容"访问时间"设定为当前时间
touch -m
	只将文件的"修改时间"设定为当前时间

touch -t timestamp

	
	指定所要设定的时间戳



文件名通配符

操作命令行时常会遇到需要一次描述多个文件的情况。
比如说，linux系统上所有的shell都支持文件名通配符(filename wildcard)来表示一组文件的集合。

例如，/usr/src/*.c 代表/usr/src/目录下的所有名称结尾.c的文件

/tmp/??.tmp代表/tmp/目录下的名称类似ll.tmp,ab.tmp,x6.tmp的所有文件。


这种内涵通配符的文件，称为file globs,而使用通配符的行为则称为globbing


shell会找出符合条件的所有文件名，编译出完整的自变量列表，然后才传给工具程序。




通配符的应用实例


1.帮助查找文件。


ls -l *linux*

2.组织与管理

mkdir perl python

mv *.pl perl
mv *.py python


3.数据检索。

ls con*/*/inv*.txt



课题103.4 流、 管道与重定向的运用


一切皆为文件(everyting is a file)
除了我们平常熟悉的数据文件之外，磁盘驱动器，磁盘分区，磁带机，终端机，
串行端口，鼠标甚至是声卡都视为文件，几乎都可以在/dev目录下找到对应的节点----也就是所谓的"设备文件"(device file)或"特殊文件"(special file)

应用程序可以用操作一般文件的逻辑来操作设备文件，程序可以对设备文件进行开启，读，写，改变文件指标，关闭等操作，
而这些操作将触发驱动程序发挥对应的功能

以终端(terminal)为例，当程序读取终端机设备文件时，会得到用户所键入的字符；当程序将字符串写入终端机设备文件时，
将可使字符串出现在屏幕上。
虽然把终端机作为文件的想法，
linux提供了简单一致的使用方法与程序设计环境


标准I/O与默认文件描述符


"标准I/O" 是shell的一种能力，用于控制或引导基于文本的Linux工具的输入，输出以及错误信息。
每个shell启动一个程序时，会预先给该程序提供三个“文件描述符”(File Descriptor,FD).

唯一例外的硬件是网卡。应用程序并非通过/dev节点来访问网卡，而是通过Linux内核提供的软件队列来收发网络封包。


事实上，大多数网络应用陈旭也不是直接透过内核队列来访问网络，而是透过socket(这也是一种文件)


从程序设计的角度来看，FD是一种含有文件控制信息的数据结构，让程序用来作为某文件的句柄(handle),所以FD也称为file handle(文件句柄)
标准I\O 会产生下列三个代码：


标准输入(standard input)
	标准输入通常简称stdin或称为FD 0.stdin是一个文字输入流，默认情况下，它连接到键盘。
	当你对一个交互式的文字程序键入字符时，程序是从stdin收到所键入的字符。不过有许多程序的命令行自变量可接受一个或多个
	文件的文件名，在这种情况下，stdin会被忽略

标准输出(standard output)
	 标准呢输出通常称为stdout或FD 1.stdout是一个文字输出流，供程序用于输出平常的信息。
	在默认情况下，stdout是接到终端机屏幕(或仿真终端机的窗口)，让程序写到stdout的出现在屏幕上

标准错误信息输出(standard error)

	标准错误信息输出通常简称为stderr或FD 2.	也是一个文字输出流，
	而且也是接到终端机屏幕或仿真终端机的窗口,这表示程序送到stderr与stdout的信息都会出现在屏幕上

	提供stdout与stderr这两个不同的FD,不只是为了让程序可将正常信息和错误信息分开，重要的是可避免错误信息干扰
	了管道处理流程

	对程序而言，标准i/o文件句柄的用法其实与一般磁盘文件的句柄一样。
	区别是前者是由shell代为创建，而后者是由进程本身于运行时自行创建。



管道(pipe)
从程序的观点来看，读取键盘(stdin)的动作月读取文件没有区别。
写出信息到文件的动作其实无异于写出信息到屏幕(stdout)。可将一个程序的输出输出转接到另一个程序的输入，
而联系两个程序的机制便称为"管道"(pipe) 
在命令行中，代表管道的符号是 |

grep "01523" order* | less

上面两个命令，管道符号之前是一个grep搜索命令，之后是一个单薄的less分页查询工具管道将grep送到标准输出的信息转接到less
的标准输入。
我们可以分页查看当前工作目录下文件名开头为order的所有文件以及任何含有01523字样的文本行



由于stdin/stdout是shell预先为程序建立的，所以管道的作用也是要靠shell来完成，
程序本身无法介入。
在同一个命令行可以同时存在一个以上的管道，形成所谓的流水线(pipeline)或文本流(text stream)

是指文字会从一个命令流动到下一个命令


管道的应用相当多元化

grep "File does not exist" error_log | awk '{print $13}' | sort > uniq -c | sort -nr | less


先从grep从网站的错误信息日志文件(error_log)中找到含有"File does not exist"字样的记录，然后以awk显示出第13个
字段(找不到的文件名)，然后排序，计算重复次数(uniq -c),再依据重复次数进行降序排序，最后将汇整结果交给less来分页显示


I/O 重定向


shell 提供了两种I/O 重定向符号，分别为<与>


cmd < file 
cmd > file

< 将文件接到命令的标准输入
> 将命令的标准输出送到文件

这两个符号改变了命令的I/O方向，合称为重定向(redirection)操作
如同管道，I/O重定向也是shell的功能，
程序本身不会察觉它们的输出被转到其他地方或是输入被换成其他来源


把用less分而已查看结果，换成> file，就可以保存了


grep "File does not exist" error_log | awk '{print $13}' | sort 
|uniq -c | sort -nr > /tmp/hot_missedpages


>会覆盖，  >>是追加新内容

> >> 都只是改变了stdout的出处，stderr依然会指向屏幕

nptdate 会取得网络时间来校正自己的系统时间。

将stdout或stderr转入文件时，shell会事先创建或开启目标文件，
然后才执行你的命令。
如果将stdout与stderr都转入同一个文件，则会发生竞争现象(race condition)
将无法得到确切的文件内容，甚至无法得到完整的信息

如果要将stdout与stderr都送到同一个文件，

ntpdate pool.ntp.org > /tmp/msg 2 >&


先将ntpdate pool.ntp.org命令的stdout (FD 1)导入/tmp/msg
然后将FD2(stderr)导入FD1所指之处(已经指向/tmp/msg文件了)
使用m>&n 语法时次序很重要，它的意义是将m指向n所指之处


ntpdate pool.ntp.org 2&>1 > /tmp/msg

则stderr的信息依然会出现在屏幕上，因为bash是从左往右解释命令的，
先将stderr指向stdout所指之处(屏幕)，然后才将stdout指向/tmp/msg文件

当你使用I/O重定向来创建文件时，必须避免同一个文件及时输入文件又是输出文件

不要直接改名字，

正确的做法是将执行结果输出到另一个临时文件，然后再改名(移动)回来

grep "stuff" file1 > file2
mv file2 file1


shell为程序默认的stdin是键盘，而你可以用<将它改成其他来源，通常是已含有适当内容的文件

比如myreport.txt文件的内容邮递给jdean@example.com;

mail -s "Daily Report" jdean@example.com < myreport.txt

在不改变stdin的情况下，mail原本会在终端机(stdin)提示用户输入邮件内容，
但由于我们将stdin指向myreport.txt文件，
所以这次你无需输入任何信息,mail也不会出现任何提示


常用的标准i/o重定向用

bash 语法                   重定向功能
cmd > file  将stdout(FD 1) 传送至file
cmd 1> file  将stderr(FD 2) 传送至file
cmd 2> file  将 stdout与stderr同时传送至file  
cmd > file 2>&1  将stdout与stderr分别传送至不同的文件
cmd > file1 2> file2    改从file接收stdin
cmd < file   将stdout附加至file的末端
cmd >> file  将stderr附加至file的末尾
cmd 1>> file  将stdout与stderr同时附加至file的末端
cmd 2>> file  将cmd1 的stdout与stderr都导入cmd2的stdin
cmd >> file  2>&1 
cmd1 | cmd2
cmd1 2 >&1 | cmd2




使用tee命令

管道与i/o重定向可以改变命令的i/o流方向，却不能复制流。
在屏幕上看到命令的执行情况，但同时又想将执行结果存入文件以便时候重复查看，可以利用tee来赋值I/O流

tee

语法
	tee [options] files

说明

将读取字stdin输入流同时复制到stdout与所指定的文件，就像T型水管接头那样

tee -a
	将输出流附加到files文件尾之后，不覆盖原有呢哦荣能够

范例

管道命令是由cmd1,cmd2,cmd3串接而成，其执行结果最后会被存入file1

cmd1 | cmd2 | cmd3 > file1

除了错误信息之外，要正常的输出信息，因为它们不是被导入下一个命令就是被转入文件。

cmd1 | tee file_cmd1 | cmd2 | cmd3 > file1


课题103.5 :进程的创建，监控与撤销


系统管理这的两项主要基本职责是文件管理与进程管理。

进程管理(process management)的用意在于保持系统能够平稳运行。通常，进程启动后的环境准备，运作和终结都是以内核自动
控管，无需管理者的介入

有时，也需要终止或重启一些大消耗的系统资源进程。

可能要发送某些特殊信号(signal)给运作中的进程，促使其进行某种预期中的动作
比如，你的服务器上有一组不能停止运作的重要进程，而你修改了它的配置文件，这时候就可能需要
送出能使其重新加载配置文件的信号


进程(process) 是“运行中的程序”(running procedure)的计算单位
对内核而言，于系统上运行的每一个"程序"(program)  ----无论是命令(command),应用程序(application)还是脚本(script)
全都是“进程的组合”

当登录系统时，自动启动的bash shell本身也是进程。你在shell中所键入的每个命令都会触发一个或多个进程，某些进程甚至会衍生
出新进程，称为子进程(child process)

1.生命周期(lifetime)
	进程的整个执行期间称为"生命周期"(lifeme).用户于命令行触发的进程(例如，ls)
	它们的生命周期多半相当短暂。但是对于提供公共服务的服务器进程(例如Apache web server)
	它们的生命周期就相当长，甚至是在系统启动之后就开始，直到关机或管理这予以结束时为止。一般而言，有daemon或server称号的程序
	几乎都是声明周期相当长的进程。
	进程结束其生命周期的状态我们称之为die(死亡)，而能够促成死亡的工具就是kill.
	因为它通常也能够传送不会造成进程死亡的其他信号(signal)给进程

2.进程标识符(ProcessID ，简称PID)
P127
